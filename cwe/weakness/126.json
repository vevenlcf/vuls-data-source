{
  "id": "126",
  "name": "Buffer Over-read",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.",
  "extended_description": "This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "125",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "788",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Confidentiality"
      ],
      "impact": [
        "Read Memory"
      ]
    },
    {
      "scope": [
        "Confidentiality"
      ],
      "impact": [
        "Bypass Protection Mechanism"
      ],
      "note": "By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service."
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-91",
      "text": "\n               \u003cIntro_Text\u003eIn the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint processMessageFromSocket(int socket) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint success;\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003echar buffer[BUFFER_SIZE];\u003cxhtml:br/\u003echar message[MESSAGE_SIZE];\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e// get message from socket and store into buffer\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e//Ignoring possibliity that buffer \u0026gt; BUFFER_SIZE\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003eif (getMessage(socket, buffer, BUFFER_SIZE) \u0026gt; 0) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// place contents of the buffer into message structure\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003eExMessage *msg = recastBuffer(buffer);\u003cxhtml:br/\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// copy message body into string for processing\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003eint index;\u003cxhtml:br/\u003efor (index = 0; index \u0026lt; msg-\u0026gt;msgLength; index++) {\u003cxhtml:div style=\"margin-left:10px;\"\u003emessage[index] = msg-\u0026gt;msgBody[index];\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003emessage[index] = '\\0';\u003cxhtml:br/\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// process message\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003esuccess = processMessage(message);\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn success;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130).\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThe following C/C++ example demonstrates a buffer over-read due to a missing NULL terminator. The main method of a pattern matching utility that looks for a specific pattern within a specific file uses the string strncopy() method to copy the command line user input file name and pattern to the Filename and Pattern character arrays respectively.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint main(int argc, char **argv)\u003cxhtml:br/\u003e{\u003cxhtml:br/\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003echar Filename[256];\u003cxhtml:br/\u003echar Pattern[32];\u003cxhtml:br/\u003e\n                        \u003cxhtml:br/\u003e\n                        \u003cxhtml:i\u003e/* Validate number of parameters and ensure valid content */\u003c/xhtml:i\u003e\n                        \u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                        \u003cxhtml:br/\u003e\n                        \u003cxhtml:i\u003e/* copy filename parameter to variable, may cause off-by-one overflow */\u003c/xhtml:i\u003e\n                        \u003cxhtml:br/\u003estrncpy(Filename, argv[1], sizeof(Filename));\u003cxhtml:br/\u003e\n                        \u003cxhtml:br/\u003e\n                        \u003cxhtml:i\u003e/* copy pattern parameter to variable, may cause off-by-one overflow */\u003c/xhtml:i\u003e\n                        \u003cxhtml:br/\u003estrncpy(Pattern, argv[2], sizeof(Pattern));\u003cxhtml:br/\u003e\n                        \u003cxhtml:br/\u003eprintf(\"Searching file: %s for the pattern: %s\\n\", Filename, Pattern);\u003cxhtml:br/\u003eScan_File(Filename, Pattern);\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the code do not take into account that strncpy() will not add a NULL terminator when the source buffer is equal in length of longer than that provide size attribute. Therefore if a user enters a filename or pattern that are the same size as (or larger than) their respective character arrays, a NULL terminator will not be added (CWE-170) which leads to the printf() read beyond the expected end of the Filename and Pattern buffers.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eTo fix this problem, be sure to subtract 1 from the sizeof() call to allow room for the null byte to be added.\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"good\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:i\u003e/* copy filename parameter to variable, no off-by-one overflow */\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003estrncpy(Filename, argv[2], sizeof(Filename)-1);\u003cxhtml:br/\u003eFilename[255]='\\0';\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e/* copy pattern parameter to variable, no off-by-one overflow */\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003estrncpy(Pattern, argv[3], sizeof(Pattern)-1);\u003c/xhtml:div\u003ePattern[31]='\\0';\u003cxhtml:br/\u003e\n               \u003c/Example_Code\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2014-0160",
      "description": "Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160"
    },
    {
      "reference": "CVE-2009-2523",
      "description": "Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2523"
    }
  ],
  "references": [
    {
      "reference_id": "REF-1034",
      "author": [
        "Raoul Strackx",
        "Yves Younan",
        "Pieter Philippaerts",
        "Frank Piessens",
        "Sven Lachmund",
        "Thomas Walter"
      ],
      "title": "Breaking the memory secrecy assumption",
      "url": "https://dl.acm.org/citation.cfm?doid=1519144.1519145",
      "publication_year": "2009",
      "publication_month": "--03",
      "publication_day": "---31",
      "publisher": "ACM"
    },
    {
      "reference_id": "REF-1035",
      "author": [
        "Fermin J. Serna"
      ],
      "title": "The info leak era on software exploitation",
      "url": "https://media.blackhat.com/bh-us-12/Briefings/Serna/BH_US_12_Serna_Leak_Era_Slides.pdf",
      "publication_year": "2012",
      "publication_month": "--07",
      "publication_day": "---25"
    },
    {
      "section": "\"Sin 5: Buffer Overruns.\" Page 89",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Relationships, Taxonomy_Mappings, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Description, Relationship_Notes, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Observed_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Causal_Nature, Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-09-19T00:00:00Z",
        "modification_comment": "updated Common_Consequences, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Primary"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Buffer over-read"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Buffer Access",
      "entry_id": "SFP8"
    }
  ],
  "notes": [
    {
      "type": "Relationship",
      "text": "These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable."
    }
  ]
}
