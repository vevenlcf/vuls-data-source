{
  "id": "120",
  "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
  "extended_description": "A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the program copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1340",
      "ordinal": "Primary"
    },
    {
      "nature": "CanPrecede",
      "cweid": "123",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "20",
      "view_id": "700",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "class": "Assembly",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "High",
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "Execute Unauthorized Code or Commands"
      ],
      "note": "Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service."
    },
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "DoS: Crash, Exit, or Restart",
        "DoS: Resource Consumption (CPU)"
      ],
      "note": "Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
    }
  ],
  "potential_mitigations": [
    {
      "mitigation_id": "MIT-3",
      "phase": [
        "Requirements"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eFor example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eBe wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.\u003c/xhtml:p\u003e\n               "
      ],
      "strategy": "Language Selection"
    },
    {
      "mitigation_id": "MIT-4.1",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eExamples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness_notes": "This is not a complete solution, since many buffer overflows are not related to strings.",
      "strategy": "Libraries or Frameworks"
    },
    {
      "mitigation_id": "MIT-10",
      "phase": [
        "Build and Compilation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eFor example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not necessarily a complete solution, since these mechanisms can only detect certain types of overflows. In addition, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Compilation or Build Hardening"
    },
    {
      "mitigation_id": "MIT-9",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eConsider adhering to the following rules when allocating and managing an application's memory:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:ul\u003e\n                        \u003cxhtml:li\u003eDouble check that your buffer is as large as you specify.\u003c/xhtml:li\u003e\n                        \u003cxhtml:li\u003eWhen using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.\u003c/xhtml:li\u003e\n                        \u003cxhtml:li\u003eCheck buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.\u003c/xhtml:li\u003e\n                        \u003cxhtml:li\u003eIf necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.\u003c/xhtml:li\u003e\n                     \u003c/xhtml:ul\u003e\n                  \u003c/xhtml:div\u003e\n               "
      ]
    },
    {
      "mitigation_id": "MIT-5",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eDo not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\u003c/xhtml:p\u003e\n               "
      ],
      "strategy": "Input Validation"
    },
    {
      "mitigation_id": "MIT-15",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      ]
    },
    {
      "mitigation_id": "MIT-11",
      "phase": [
        "Operation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eExamples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not a complete solution. However, it forces the attacker to guess an unknown value that changes every program execution. In addition, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-12",
      "phase": [
        "Operation"
      ],
      "description": [
        "Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61]."
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Environment Hardening"
    },
    {
      "phase": [
        "Build and Compilation",
        "Operation"
      ],
      "description": [
        "Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution."
      ]
    },
    {
      "mitigation_id": "MIT-13",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available."
      ],
      "effectiveness": "Moderate",
      "effectiveness_notes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
    },
    {
      "mitigation_id": "MIT-21",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      ],
      "strategy": "Enforcement by Conversion"
    },
    {
      "mitigation_id": "MIT-17",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      ],
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-22",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eBe careful to avoid CWE-243 and other weaknesses related to jails.\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Limited",
      "effectiveness_notes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed.",
      "strategy": "Sandbox or Jail"
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThe following code asks the user to enter their last name and then attempts to store the value entered in the last_name array.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar last_name[20];\u003cxhtml:br/\u003eprintf (\"Enter your last name: \");\u003cxhtml:br/\u003escanf (\"%s\", last_name);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe problem with the code above is that it does not restrict or limit the size of the name entered by the user. If the user enters \"Very_very_long_last_name\" which is 24 characters long, then a buffer overflow will occur since the array can only hold 20 characters total.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-6",
      "text": "\n               \u003cIntro_Text\u003eThe following code attempts to create a local copy of a buffer to perform some manipulations to the data.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003evoid manipulate_string(char * string){\u003cxhtml:div style=\"margin-left:10px;\"\u003echar buf[24];\u003cxhtml:br/\u003estrcpy(buf, string);\u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the programmer does not ensure that the size of the data pointed to by string will fit in the local buffer and copies the data with the potentially dangerous strcpy() function. This may result in a buffer overflow condition if an attacker can influence the contents of the string parameter.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-5",
      "text": "\n               \u003cIntro_Text\u003eThe code below calls the gets() function to read in data from the command line.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003echar buf[24];\u003cxhtml:br/\u003eprintf(\"Please enter your name and press \u0026lt;Enter\u0026gt;\\n\");\u003cxhtml:br/\u003egets(buf);\u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, gets() is inherently unsafe, because it copies all input from STDIN to the buffer without checking size. This allows the user to provide a string that is larger than the buffer size, resulting in an overflow condition.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eIn the following example, a server accepts connections from a client and processes the client request. After accepting a client connection, the program will obtain client information using the gethostbyaddr method, copy the hostname of the client that connected to a local variable and output the hostname of the client to a log file.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e...\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003estruct hostent *clienthp;\u003cxhtml:br/\u003echar hostname[MAX_LEN];\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e// create server socket, bind to server address and listen on socket\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e// accept client connections and process requests\u003cxhtml:br/\u003eint count = 0;\u003cxhtml:br/\u003efor (count = 0; count \u0026lt; MAX_CONNECTIONS; count++) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003e\n                                 \u003cxhtml:br/\u003eint clientlen = sizeof(struct sockaddr_in);\u003cxhtml:br/\u003eint clientsocket = accept(serversocket, (struct sockaddr *)\u0026amp;clientaddr, \u0026amp;clientlen);\u003cxhtml:br/\u003e\n                                 \u003cxhtml:br/\u003eif (clientsocket \u0026gt;= 0) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                                    \u003cxhtml:div\u003eclienthp = gethostbyaddr((char*) \u0026amp;clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);\u003cxhtml:br/\u003estrcpy(hostname, clienthp-\u0026gt;h_name);\u003cxhtml:br/\u003elogOutput(\"Accepted client connection from host \", hostname);\u003cxhtml:br/\u003e\n                                       \u003cxhtml:br/\u003e// process client request\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003eclose(clientsocket);\u003c/xhtml:div\u003e\n                                 \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eclose(serversocket);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e\n                     \u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the hostname of the client that connected may be longer than the allocated size for the local hostname variable. This will result in a buffer overflow when copying the client hostname to the local variable using the strcpy method.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2000-1094",
      "description": "buffer overflow using command with long argument",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1094"
    },
    {
      "reference": "CVE-1999-0046",
      "description": "buffer overflow in local program using long environment variable",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-0046"
    },
    {
      "reference": "CVE-2002-1337",
      "description": "buffer overflow in comment characters, when product increments a counter for a \"\u003e\" but does not decrement for \"\u003c\"",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1337"
    },
    {
      "reference": "CVE-2003-0595",
      "description": "By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0595"
    },
    {
      "reference": "CVE-2001-0191",
      "description": "By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0191"
    }
  ],
  "references": [
    {
      "section": "Chapter 5, \"Public Enemy #1: The Buffer Overrun\" Page 127",
      "reference_id": "REF-7",
      "author": [
        "Michael Howard",
        "David LeBlanc"
      ],
      "title": "Writing Secure Code",
      "url": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223",
      "publication_year": "2002",
      "publication_month": "--12",
      "publication_day": "---04",
      "publisher": "Microsoft Press",
      "edition": "2nd Edition"
    },
    {
      "section": "\"Sin 5: Buffer Overruns.\" Page 89",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "reference_id": "REF-56",
      "author": [
        "Microsoft"
      ],
      "title": "Using the Strsafe.h Functions",
      "url": "http://msdn.microsoft.com/en-us/library/ms647466.aspx"
    },
    {
      "reference_id": "REF-57",
      "author": [
        "Matt Messier",
        "John Viega"
      ],
      "title": "Safe C String Library v1.0.3",
      "url": "http://www.zork.org/safestr/"
    },
    {
      "reference_id": "REF-58",
      "author": [
        "Michael Howard"
      ],
      "title": "Address Space Layout Randomization in Windows Vista",
      "url": "http://blogs.msdn.com/michael_howard/archive/2006/05/26/address-space-layout-randomization-in-windows-vista.aspx"
    },
    {
      "reference_id": "REF-59",
      "author": [
        "Arjan van de Ven"
      ],
      "title": "Limiting buffer overflows with ExecShield",
      "url": "http://www.redhat.com/magazine/009jul05/features/execshield/"
    },
    {
      "reference_id": "REF-60",
      "title": "PaX",
      "url": "http://en.wikipedia.org/wiki/PaX"
    },
    {
      "reference_id": "REF-74",
      "author": [
        "Jason Lam"
      ],
      "title": "Top 25 Series - Rank 3 - Classic Buffer Overflow",
      "url": "http://software-security.sans.org/blog/2010/03/02/top-25-series-rank-3-classic-buffer-overflow/",
      "publication_year": "2010",
      "publication_month": "--03",
      "publication_day": "---02",
      "publisher": "SANS Software Security Institute"
    },
    {
      "reference_id": "REF-61",
      "author": [
        "Microsoft"
      ],
      "title": "Understanding DEP as a mitigation technology part 1",
      "url": "http://blogs.technet.com/b/srd/archive/2009/06/12/understanding-dep-as-a-mitigation-technology-part-1.aspx"
    },
    {
      "reference_id": "REF-76",
      "author": [
        "Sean Barnum",
        "Michael Gegick"
      ],
      "title": "Least Privilege",
      "url": "https://buildsecurityin.us-cert.gov/daisy/bsi/articles/knowledge/principles/351.html",
      "publication_year": "2005",
      "publication_month": "--09",
      "publication_day": "---14"
    },
    {
      "section": "Chapter 3, \"Nonexecutable Stack\", Page 76",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "Chapter 5, \"Protection Mechanisms\", Page 189",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "Chapter 8, \"C String Handling\", Page 388",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "reference_id": "REF-64",
      "author": [
        "Grant Murphy"
      ],
      "title": "Position Independent Executables (PIE)",
      "url": "https://securityblog.redhat.com/2012/11/28/position-independent-executables-pie/",
      "publication_year": "2012",
      "publication_month": "--11",
      "publication_day": "---28",
      "publisher": "Red Hat"
    },
    {
      "section": "ASCRM-CWE-120",
      "reference_id": "REF-961",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Reliability Measure (ASCRM)",
      "url": "http://www.omg.org/spec/ASCRM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    },
    {
      "section": "ASCSM-CWE-120",
      "reference_id": "REF-962",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Security Measure (ASCSM)",
      "url": "http://www.omg.org/spec/ASCSM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01T00:00:00Z",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_organization": "Veracode",
        "modification_date": "2008-08-15T00:00:00Z",
        "modification_comment": "Suggested OWASP Top Ten 2004 mapping"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Applicable_Platforms, Common_Consequences, Relationships, Observed_Example, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-10T00:00:00Z",
        "modification_comment": "Changed name and description to more clearly emphasize the \"classic\" nature of the overflow."
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-14T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Description, Name, Other_Notes, Terminology_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Other_Notes, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-01-12T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Other_Notes, Potential_Mitigations, References, Relationship_Notes, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-07-27T00:00:00Z",
        "modification_comment": "updated Other_Notes, Potential_Mitigations, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings, Time_of_Introduction, Type"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-04-05T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-06-21T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-12-13T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Detection_Factors, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Causal_Nature, Demonstrative_Examples, Likelihood_of_Exploit, References, Relationships, Taxonomy_Mappings, White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-07-20T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Unbounded Transfer ('Classic Buffer Overflow')",
        "date": "2008-10-14T00:00:00Z"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Resultant"
    },
    {
      "ordinality": "Primary"
    }
  ],
  "alternate_terms": [
    {
      "term": "Classic Buffer Overflow",
      "description": "This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques."
    },
    {
      "term": "Unbounded Transfer"
    }
  ],
  "detection_methods": [
    {
      "detection_method_id": "DM-1",
      "method": "Automated Static Analysis",
      "description": "\n                  \u003cxhtml:p\u003eThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eAutomated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\u003c/xhtml:p\u003e\n               ",
      "effectiveness": "High",
      "effectiveness_notes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
    },
    {
      "detection_method_id": "DM-2",
      "method": "Automated Dynamic Analysis",
      "description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
    },
    {
      "detection_method_id": "DM-9",
      "method": "Manual Analysis",
      "description": "Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."
    },
    {
      "method": "Automated Static Analysis - Binary or Bytecode",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eBytecode Weakness Analysis - including disassembler + source code weakness analysis\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eBinary Weakness Analysis - including disassembler + source code weakness analysis\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Manual Static Analysis - Binary or Bytecode",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eBinary / Bytecode disassembler - then use manual analysis for vulnerabilities \u0026amp; anomalies\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Dynamic Analysis with Automated Results Interpretation",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eWeb Application Scanner\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eWeb Services Scanner\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eDatabase Scanners\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Dynamic Analysis with Manual Results Interpretation",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eFuzz Tester\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eFramework-based Fuzzer\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Manual Static Analysis - Source Code",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eFocused Manual Spotcheck - Focused manual analysis of source\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eManual Source Code Review (not inspections)\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Automated Static Analysis - Source Code",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eSource code Weakness Analyzer\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eContext-configured Source Code Weakness Analyzer\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Architecture or Design Review",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eFormal Methods / Correct-By-Construction\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Unbounded Transfer ('classic overflow')"
    },
    {
      "taxonomy_name": "7 Pernicious Kingdoms",
      "entry_name": "Buffer Overflow"
    },
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Buffer overflow"
    },
    {
      "taxonomy_name": "OWASP Top Ten 2004",
      "entry_name": "Unvalidated Input",
      "entry_id": "A1",
      "mapping_fit": "CWE More Specific"
    },
    {
      "taxonomy_name": "OWASP Top Ten 2004",
      "entry_name": "Buffer Overflows",
      "entry_id": "A5",
      "mapping_fit": "CWE More Specific"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
      "entry_id": "STR31-C",
      "mapping_fit": "Exact"
    },
    {
      "taxonomy_name": "WASC",
      "entry_name": "Buffer Overflow",
      "entry_id": "7"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Buffer Access",
      "entry_id": "SFP8"
    },
    {
      "taxonomy_name": "OMG ASCSM",
      "entry_id": "ASCSM-CWE-120"
    },
    {
      "taxonomy_name": "OMG ASCRM",
      "entry_id": "ASCRM-CWE-120"
    }
  ],
  "related_attack_patterns": [
    "10",
    "100",
    "14",
    "24",
    "42",
    "44",
    "45",
    "46",
    "47",
    "67",
    "8",
    "9",
    "92"
  ],
  "notes": [
    {
      "type": "Relationship",
      "text": "At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them."
    },
    {
      "type": "Terminology",
      "text": "Many issues that are now called \"buffer overflows\" are substantively different than the \"classic\" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported."
    }
  ],
  "affected_resources": [
    "Memory"
  ],
  "functional_areas": [
    "Memory Management"
  ]
}
