{
  "id": "131",
  "name": "Incorrect Calculation of Buffer Size",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1340",
      "ordinal": "Primary"
    },
    {
      "nature": "CanPrecede",
      "cweid": "119",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "High",
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Availability",
        "Confidentiality"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart",
        "Execute Unauthorized Code or Commands",
        "Read Memory",
        "Modify Memory"
      ],
      "note": "If the incorrect calculation is used in the context of memory allocation, then the software may create a buffer that is smaller or larger than expected. If the allocated buffer is smaller than expected, this could lead to an out-of-bounds read or write (CWE-119), possibly causing a crash, allowing arbitrary code execution, or exposing sensitive data."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts \"\u0026amp;\" characters to \"\u0026amp;amp;\" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer."
      ]
    },
    {
      "mitigation_id": "MIT-36",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eUnderstand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eAlso be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.\u003c/xhtml:p\u003e\n               "
      ]
    },
    {
      "mitigation_id": "MIT-8",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range."
      ],
      "strategy": "Input Validation"
    },
    {
      "mitigation_id": "MIT-15",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130)."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated."
      ]
    },
    {
      "mitigation_id": "MIT-13",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available."
      ],
      "effectiveness": "Moderate",
      "effectiveness_notes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131). Additionally, this only addresses potential overflow issues. Resource consumption / exhaustion issues are still possible."
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Use sizeof() on the appropriate data type to avoid CWE-467."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify validation and will reduce surprises related to unexpected casting."
      ]
    },
    {
      "mitigation_id": "MIT-4",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eUse libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eExamples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]\u003c/xhtml:p\u003e\n               "
      ],
      "strategy": "Libraries or Frameworks"
    },
    {
      "mitigation_id": "MIT-10",
      "phase": [
        "Build and Compilation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eFor example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not necessarily a complete solution, since these mechanisms can only detect certain types of overflows. In addition, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Compilation or Build Hardening"
    },
    {
      "mitigation_id": "MIT-11",
      "phase": [
        "Operation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eExamples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not a complete solution. However, it forces the attacker to guess an unknown value that changes every program execution. In addition, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-12",
      "phase": [
        "Operation"
      ],
      "description": [
        "Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-61] [REF-60]."
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application.",
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-26",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."
      ],
      "strategy": "Compilation or Build Hardening"
    },
    {
      "mitigation_id": "MIT-17",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      ],
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-22",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eBe careful to avoid CWE-243 and other weaknesses related to jails.\u003c/xhtml:p\u003e\n               "
      ],
      "effectiveness": "Limited",
      "effectiveness_notes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed.",
      "strategy": "Sandbox or Jail"
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-20",
      "text": "\n               \u003cIntro_Text\u003eThe following code allocates memory for a maximum number of widgets. It then gets a user-specified number of widgets, making sure that the user does not request too many. It then initializes the elements of the array using InitializeWidget(). Because the number of widgets can vary for each request, the code inserts a NULL pointer to signify the location of the last widget.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint i;\u003cxhtml:br/\u003eunsigned int numWidgets;\u003cxhtml:br/\u003eWidget **WidgetList;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003enumWidgets = GetUntrustedSizeValue();\u003cxhtml:br/\u003eif ((numWidgets == 0) || (numWidgets \u0026gt; MAX_NUM_WIDGETS)) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eExitError(\"Incorrect number of widgets requested!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\u003cxhtml:br/\u003eprintf(\"WidgetList ptr=%p\\n\", WidgetList);\u003cxhtml:br/\u003efor(i=0; i\u0026lt;numWidgets; i++) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eWidgetList[i] = InitializeWidget();\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eWidgetList[numWidgets] = NULL;\u003cxhtml:br/\u003eshowWidgets(WidgetList);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, this code contains an off-by-one calculation error (CWE-193). It allocates exactly enough space to contain the specified number of widgets, but it does not include the space for the NULL pointer. As a result, the allocated buffer is smaller than it is supposed to be (CWE-131). So if the user ever requests MAX_NUM_WIDGETS, there is an out-of-bounds write (CWE-787) when the NULL is assigned. Depending on the environment and compilation settings, this could cause memory corruption.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-33",
      "text": "\n               \u003cIntro_Text\u003eThe following image processing code allocates a table for images.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eimg_t table_ptr; /*struct containing img data, 10kB each*/\u003cxhtml:br/\u003eint num_imgs;\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003enum_imgs = get_num_imgs();\u003cxhtml:br/\u003etable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThis code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119).\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-19",
      "text": "\n               \u003cIntro_Text\u003eThis example applies an encoding procedure to an input string and stores it into a buffer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar * copy_input(char *user_supplied_string){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint i, dst_index;\u003cxhtml:br/\u003echar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\u003cxhtml:br/\u003eif ( MAX_SIZE \u0026lt;= strlen(user_supplied_string) ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edie(\"user string too long, die evil hacker!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003edst_index = 0;\u003cxhtml:br/\u003efor ( i = 0; i \u0026lt; strlen(user_supplied_string); i++ ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003eif( '\u0026amp;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edst_buf[dst_index++] = '\u0026amp;';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'a';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'm';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'p';\u003cxhtml:br/\u003edst_buf[dst_index++] = ';';\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse if ('\u0026lt;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                                    \u003cxhtml:div\u003e\n                                       \u003cxhtml:br/\u003e\n                                       \u003cxhtml:i\u003e/* encode to \u0026amp;lt; */\u003c/xhtml:i\u003e\n                                       \u003cxhtml:br/\u003e\n                                    \u003c/xhtml:div\u003e\n                                 \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse dst_buf[dst_index++] = user_supplied_string[i];\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn dst_buf;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-21",
      "text": "\n               \u003cIntro_Text\u003eThe following code is intended to read an incoming packet from a socket and extract one or more headers.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eDataPacket *packet;\u003cxhtml:br/\u003eint numHeaders;\u003cxhtml:br/\u003ePacketHeader *headers;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003esock=AcceptSocketConnection();\u003cxhtml:br/\u003eReadPacket(packet, sock);\u003cxhtml:br/\u003enumHeaders =packet-\u0026gt;headers;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eif (numHeaders \u0026gt; 100) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eExitError(\"too many headers!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eheaders = malloc(numHeaders * sizeof(PacketHeader);\u003cxhtml:br/\u003eParsePacketHeaders(packet, headers);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThe following code attempts to save three different identification numbers into an array. The array is allocated from memory using a call to malloc().\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint *id_sequence;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e/* Allocate space for an array of three ids. */\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eid_sequence = (int*) malloc(3);\u003cxhtml:br/\u003eif (id_sequence == NULL) exit(1);\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e/* Populate the id array. */\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eid_sequence[0] = 13579;\u003cxhtml:br/\u003eid_sequence[1] = 24680;\u003cxhtml:br/\u003eid_sequence[2] = 97531;\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe problem with the code above is the value of the size parameter used during the malloc() call. It uses a value of '3' which by definition results in a buffer of three bytes to be created. However the intention was to create a buffer that holds three ints, and in C, each int requires 4 bytes worth of memory, so an array of 12 bytes is needed, 4 bytes for each int. Executing the above code could result in a buffer overflow as 12 bytes of data is being saved into 3 bytes worth of allocated space. The overflow would occur during the assignment of id_sequence[0] and would continue with the assignment of id_sequence[1] and id_sequence[2].\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eThe malloc() call could have used '3*sizeof(int)' as the value for the size parameter in order to allocate the correct amount of space required to store the three ints.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2020-17087",
      "description": "Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-17087"
    },
    {
      "reference": "CVE-2004-1363",
      "description": "substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1363"
    },
    {
      "reference": "CVE-2004-0747",
      "description": "substitution overflow: buffer overflow using expansion of environment variables",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0747"
    },
    {
      "reference": "CVE-2005-2103",
      "description": "substitution overflow: buffer overflow using a large number of substitution strings",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2103"
    },
    {
      "reference": "CVE-2005-3120",
      "description": "transformation overflow: product adds extra escape characters to incoming data, but does not account for them in the buffer length",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3120"
    },
    {
      "reference": "CVE-2003-0899",
      "description": "transformation overflow: buffer overflow when expanding \"\u003e\" to \"\u0026gt;\", etc.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0899"
    },
    {
      "reference": "CVE-2001-0334",
      "description": "expansion overflow: buffer overflow using wildcards",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0334"
    },
    {
      "reference": "CVE-2001-0248",
      "description": "expansion overflow: long pathname + glob = overflow",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0248"
    },
    {
      "reference": "CVE-2001-0249",
      "description": "expansion overflow: long pathname + glob = overflow",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0249"
    },
    {
      "reference": "CVE-2002-0184",
      "description": "special characters in argument are not properly expanded",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0184"
    },
    {
      "reference": "CVE-2004-0434",
      "description": "small length value leads to heap overflow",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0434"
    },
    {
      "reference": "CVE-2002-1347",
      "description": "multiple variants",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1347"
    },
    {
      "reference": "CVE-2005-0490",
      "description": "needs closer investigation, but probably expansion-based",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0490"
    },
    {
      "reference": "CVE-2004-0940",
      "description": "needs closer investigation, but probably expansion-based",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0940"
    },
    {
      "reference": "CVE-2008-0599",
      "description": "Chain: Language interpreter calculates wrong buffer size (CWE-131) by using \"size = ptr ? X : Y\" instead of \"size = (ptr ? X : Y)\" expression.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0599"
    }
  ],
  "references": [
    {
      "reference_id": "REF-106",
      "author": [
        "David LeBlanc",
        "Niels Dekker"
      ],
      "title": "SafeInt",
      "url": "http://safeint.codeplex.com/"
    },
    {
      "reference_id": "REF-107",
      "author": [
        "Jason Lam"
      ],
      "title": "Top 25 Series - Rank 18 - Incorrect Calculation of Buffer Size",
      "url": "http://software-security.sans.org/blog/2010/03/19/top-25-series-rank-18-incorrect-calculation-of-buffer-size",
      "publication_year": "2010",
      "publication_month": "--03",
      "publication_day": "---19",
      "publisher": "SANS Software Security Institute"
    },
    {
      "reference_id": "REF-58",
      "author": [
        "Michael Howard"
      ],
      "title": "Address Space Layout Randomization in Windows Vista",
      "url": "http://blogs.msdn.com/michael_howard/archive/2006/05/26/address-space-layout-randomization-in-windows-vista.aspx"
    },
    {
      "reference_id": "REF-61",
      "author": [
        "Microsoft"
      ],
      "title": "Understanding DEP as a mitigation technology part 1",
      "url": "http://blogs.technet.com/b/srd/archive/2009/06/12/understanding-dep-as-a-mitigation-technology-part-1.aspx"
    },
    {
      "reference_id": "REF-60",
      "title": "PaX",
      "url": "http://en.wikipedia.org/wiki/PaX"
    },
    {
      "reference_id": "REF-76",
      "author": [
        "Sean Barnum",
        "Michael Gegick"
      ],
      "title": "Least Privilege",
      "url": "https://buildsecurityin.us-cert.gov/daisy/bsi/articles/knowledge/principles/351.html",
      "publication_year": "2005",
      "publication_month": "--09",
      "publication_day": "---14"
    },
    {
      "section": "Chapter 20, \"Integer Overflows\" Page 620",
      "reference_id": "REF-7",
      "author": [
        "Michael Howard",
        "David LeBlanc"
      ],
      "title": "Writing Secure Code",
      "url": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223",
      "publication_year": "2002",
      "publication_month": "--12",
      "publication_day": "---04",
      "publisher": "Microsoft Press",
      "edition": "2nd Edition"
    },
    {
      "section": "\"Sin 5: Buffer Overruns.\" Page 89",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "section": "Chapter 8, \"Incrementing Pointers Incorrectly\", Page 401",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "reference_id": "REF-64",
      "author": [
        "Grant Murphy"
      ],
      "title": "Position Independent Executables (PIE)",
      "url": "https://securityblog.redhat.com/2012/11/28/position-independent-executables-pie/",
      "publication_year": "2012",
      "publication_month": "--11",
      "publication_day": "---28",
      "publisher": "Red Hat"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Time_of_Introduction"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Maintenance_Notes, Relationships, Taxonomy_Mappings, Type"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-14T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-12-28T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Likelihood_of_Exploit, Observed_Examples, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Detection_Factors, Maintenance_Notes, Potential_Mitigations, Related_Attack_Patterns, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-04-05T00:00:00Z",
        "modification_comment": "updated Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-06-21T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Detection_Factors, Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-12-13T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Maintenance_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Potential_Mitigations, References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-02-21T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-07-17T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Detection_Factors, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Likelihood_of_Exploit, References, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-06-28T00:00:00Z",
        "modification_comment": "updated Observed_Examples"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Other Length Calculation Error",
        "date": "2008-01-30T00:00:00Z"
      }
    ]
  },
  "detection_methods": [
    {
      "detection_method_id": "DM-1",
      "method": "Automated Static Analysis",
      "description": "\n                  \u003cxhtml:p\u003eThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eAutomated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\u003c/xhtml:p\u003e\n               ",
      "effectiveness": "High",
      "effectiveness_notes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
    },
    {
      "detection_method_id": "DM-2",
      "method": "Automated Dynamic Analysis",
      "description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
      "effectiveness": "Moderate",
      "effectiveness_notes": "Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem."
    },
    {
      "detection_method_id": "DM-9",
      "method": "Manual Analysis",
      "description": "Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."
    },
    {
      "detection_method_id": "DM-7",
      "method": "Manual Analysis",
      "description": "\n                  \u003cxhtml:p\u003eThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eSpecifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.\u003c/xhtml:p\u003e\n               ",
      "effectiveness": "High",
      "effectiveness_notes": "These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."
    },
    {
      "method": "Automated Static Analysis - Binary or Bytecode",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eBytecode Weakness Analysis - including disassembler + source code weakness analysis\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eBinary Weakness Analysis - including disassembler + source code weakness analysis\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Manual Static Analysis - Binary or Bytecode",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eBinary / Bytecode disassembler - then use manual analysis for vulnerabilities \u0026amp; anomalies\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Manual Static Analysis - Source Code",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eFocused Manual Spotcheck - Focused manual analysis of source\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eManual Source Code Review (not inspections)\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Automated Static Analysis - Source Code",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eSource code Weakness Analyzer\u003c/xhtml:li\u003e\n                           \u003cxhtml:li\u003eContext-configured Source Code Weakness Analyzer\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eSource Code Quality Analyzer\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Architecture or Design Review",
      "description": "\n                  \u003cxhtml:p\u003eAccording to SOAR, the following detection techniques may be useful:\u003c/xhtml:p\u003e\n                  \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                     \u003cxhtml:div\u003eHighly cost effective:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eFormal Methods / Correct-By-Construction\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                     \u003cxhtml:div\u003eCost effective for partial coverage:\u003c/xhtml:div\u003e\n                     \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:ul\u003e\n                           \u003cxhtml:li\u003eInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)\u003c/xhtml:li\u003e\n                        \u003c/xhtml:ul\u003e\n                     \u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               ",
      "effectiveness": "High"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Other length calculation error"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Ensure that unsigned integer operations do not wrap",
      "entry_id": "INT30-C",
      "mapping_fit": "Imprecise"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Allocate sufficient memory for an object",
      "entry_id": "MEM35-C",
      "mapping_fit": "CWE More Abstract"
    }
  ],
  "related_attack_patterns": [
    "100",
    "47"
  ],
  "notes": [
    {
      "type": "Maintenance",
      "text": "\n               \u003cxhtml:p\u003eThis is a broad category. Some examples include:\u003c/xhtml:p\u003e\n               \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                  \u003cxhtml:ol\u003e\n                     \u003cxhtml:li\u003esimple math errors,\u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003eincorrectly updating parallel counters,\u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003enot accounting for size differences when \"transforming\" one input to another format (e.g. URL canonicalization or other transformation that can generate a result that's larger than the original input, i.e. \"expansion\").\u003c/xhtml:li\u003e\n                  \u003c/xhtml:ol\u003e\n               \u003c/xhtml:div\u003e\n               \u003cxhtml:p\u003eThis level of detail is rarely available in public reports, so it is difficult to find good examples.\u003c/xhtml:p\u003e\n            "
    },
    {
      "type": "Maintenance",
      "text": "\n               \u003cxhtml:p\u003eThis weakness may be a composite or a chain. It also may contain layering or perspective differences.\u003c/xhtml:p\u003e\n               \u003cxhtml:p\u003eThis issue may be associated with many different types of incorrect calculations (CWE-682), although the integer overflow (CWE-190) is probably the most prevalent. This can be primary to resource consumption problems (CWE-400), including uncontrolled memory allocation (CWE-789). However, its relationship with out-of-bounds buffer access (CWE-119) must also be considered.\u003c/xhtml:p\u003e\n            "
    }
  ]
}
