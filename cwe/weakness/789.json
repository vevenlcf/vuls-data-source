{
  "id": "789",
  "name": "Memory Allocation with Excessive Size Value",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Draft",
  "description": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "770",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "1284",
      "view_id": "1000"
    },
    {
      "nature": "CanPrecede",
      "cweid": "476",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "class": "Language-Independent",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "DoS: Resource Consumption (Memory)"
      ],
      "note": "Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation",
        "Architecture and Design"
      ],
      "description": [
        "Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."
      ]
    },
    {
      "phase": [
        "Operation"
      ],
      "description": [
        "Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eConsider the following code, which accepts an untrusted size value and allocates a buffer to contain a string of the given size.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eunsigned int size = GetUntrustedInt();\u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e/* ignore integer overflow (CWE-190) for this example */\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eunsigned int totBytes = size * sizeof(char);\u003cxhtml:br/\u003echar *string = (char *)malloc(totBytes);\u003cxhtml:br/\u003eInitializeString(string);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eSuppose an attacker provides a size value of:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003e12345678\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003eThis will cause 305,419,896 bytes (over 291 megabytes) to be allocated for the string.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eConsider the following code, which accepts an untrusted size value and uses the size as an initial capacity for a HashMap.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eunsigned int size = GetUntrustedInt();\u003cxhtml:br/\u003eHashMap list = new HashMap(size);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe HashMap constructor will verify that the initial capacity is not negative, however there is no check in place to verify that sufficient memory is present. If the attacker provides a large enough value, the application will run into an OutOfMemoryError.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-137",
      "text": "\n               \u003cIntro_Text\u003eThis code performs a stack allocation based on a length calculation.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e\n\t\t    int a = 5, b = 6;\u003cxhtml:br/\u003e\n\t\t    size_t len = a - b;\u003cxhtml:br/\u003e\n\t\t    char buf[len];    // Just blows up the stack\n\t\t  \u003c/xhtml:div\u003e\n\t\t  }\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eSince a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space.\u003c/Body_Text\u003e\n\t       \u003cBody_Text\u003eMiscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-138",
      "text": "\n               \u003cIntro_Text\u003eThis example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n\t\t int proc_msg(char *s, int msg_len)\u003cxhtml:br/\u003e\n\t\t {\u003cxhtml:br/\u003e\n                  \u003cxhtml:div\u003e\n\t\t    \u003cxhtml:i\u003e// Note space at the end of the string - assume all strings have preamble with space\u003c/xhtml:i\u003e\u003cxhtml:br/\u003e\n\t\t    int pre_len = sizeof(\"preamble: \");\u003cxhtml:br/\u003e\n\t\t    char buf[pre_len - msg_len];\u003cxhtml:br/\u003e\n\t\t    \u003cxhtml:i\u003e... Do processing here if we get this far\u003c/xhtml:i\u003e\n\t\t  \u003c/xhtml:div\u003e\n\t\t  }\u003cxhtml:br/\u003e\n\t\t  char *s = \"preamble: message\\n\";\u003cxhtml:br/\u003e\n\t\t  char *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\u003cxhtml:br/\u003e\n\t\t  int jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\u003cxhtml:br/\u003e\n\t\t  int ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack\u003cxhtml:br/\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThe following code obtains an untrusted number that is used as an index into an array of messages.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Perl\"\u003e\n                  \u003cxhtml:div\u003emy $num = GetUntrustedNumber();\u003cxhtml:br/\u003emy @messages = ();\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e$messages[$num] = \"Hello World\";\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe index is not validated at all (CWE-129), so it might be possible for an attacker to modify an element in @messages that was not intended. If an index is used that is larger than the current size of the array, the Perl interpreter automatically expands the array so that the large index works.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eIf $num is a large value such as 2147483648 (1\u0026lt;\u0026lt;31), then the assignment to $messages[$num] would attempt to create a very large array, then eventually produce an error message such as:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eOut of memory during array extend\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eThis memory exhaustion will cause the Perl program to exit, possibly a denial of service. In addition, the lack of memory could also prevent many other programs from successfully running on the system.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n          \u003cIntro_Text\u003eThis example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action. The buffer length ends up being -1 resulting in a blown out stack. The space character after the colon is included  in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations.\u003c/Intro_Text\u003e\n          \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\nint proc_msg(char *s, int msg_len)\u003cxhtml:br/\u003e\n{\u003cxhtml:br/\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003eint pre_len = sizeof(\"preamble: \");    // Note space at the end of the string - assume all strings have preamble with space\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003echar buf[pre_len - msg_len];\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003e... Do processing here and set status\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003ereturn status;\u003c/xhtml:div\u003e\n}\n\u003cxhtml:br/\u003e\nchar *s = \"preamble: message\\n\";\u003cxhtml:br/\u003e\nchar *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\u003cxhtml:br/\u003e\nint jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\u003cxhtml:br/\u003e\nint ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack\n         \u003c/Example_Code\u003e\n          \u003cExample_Code Nature=\"good\" Language=\"C\"\u003e\nint proc_msg(char *s, int msg_len)\u003cxhtml:br/\u003e\n{\u003cxhtml:br/\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003eint pre_len = sizeof(\"preamble: \");    // Note space at the end of the string - assume all strings have preamble with space\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003eif (pre_len \u0026lt;= msg_len) { // Log error; return error_code; }\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003echar buf[pre_len - msg_len];\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003e... Do processing here and set status\u003c/xhtml:div\u003e\n\u003cxhtml:div style=\"margin-left:10px;\"\u003ereturn status;\u003c/xhtml:div\u003e\n}\n\u003cxhtml:br/\u003e\nchar *s = \"preamble: message\\n\";\u003cxhtml:br/\u003e\nchar *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\u003cxhtml:br/\u003e\nint jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\u003cxhtml:br/\u003e\nint ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack\n         \u003c/Example_Code\u003e\n        "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2010-3701",
      "description": "program uses ::alloca() for encoding messages, but large messages trigger segfault",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3701"
    },
    {
      "reference": "CVE-2008-1708",
      "description": "memory consumption and daemon exit by specifying a large value in a length field",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1708"
    },
    {
      "reference": "CVE-2008-0977",
      "description": "large value in a length field leads to memory consumption and crash when no more memory is available",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0977"
    },
    {
      "reference": "CVE-2006-3791",
      "description": "large key size in game program triggers crash when a resizing function cannot allocate enough memory",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3791"
    },
    {
      "reference": "CVE-2004-2589",
      "description": "large Content-Length HTTP header value triggers application crash in instant messaging application due to failure in memory allocation",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2589"
    }
  ],
  "references": [
    {
      "section": "Chapter 10, \"Resource Limits\", Page 574",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "ASCSM-CWE-789",
      "reference_id": "REF-962",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Security Measure (ASCSM)",
      "url": "http://www.omg.org/spec/ASCSM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2009-10-21T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Observed_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Demonstrative_Examples, Description, Likelihood_of_Exploit, Name, Observed_Examples, Relationships, Time_of_Introduction"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Uncontrolled Memory Allocation",
        "date": "2020-12-10T00:00:00Z"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Primary"
    },
    {
      "ordinality": "Resultant"
    }
  ],
  "alternate_terms": [
    {
      "term": "Stack Exhaustion",
      "description": "When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325."
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "WASC",
      "entry_name": "SOAP Array Abuse",
      "entry_id": "35"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Allocate sufficient memory for an object",
      "entry_id": "MEM35-C",
      "mapping_fit": "Imprecise"
    },
    {
      "taxonomy_name": "SEI CERT Perl Coding Standard",
      "entry_name": "Validate any integer that is used as an array index",
      "entry_id": "IDS32-PL",
      "mapping_fit": "Imprecise"
    },
    {
      "taxonomy_name": "OMG ASCSM",
      "entry_id": "ASCSM-CWE-789"
    }
  ],
  "notes": [
    {
      "type": "Relationship",
      "text": "This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated."
    },
    {
      "type": "Applicable Platform",
      "text": "\n               \u003cxhtml:p\u003eUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\u003c/xhtml:p\u003e\n            "
    }
  ]
}
