{
  "id": "1224",
  "name": "Improper Restriction of Write-Once Bit Fields",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The hardware design control register \"sticky bits\" or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.",
  "extended_description": "\n                \u003cxhtml:p\u003eIntegrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings write-once or \"sticky.\" This allows writing to such registers only once, whereupon they become read-only. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings.\u003c/xhtml:p\u003e\n                \u003cxhtml:p\u003eFailure to implement write-once restrictions in hardware design can expose such registers to being re-programmed by software and written multiple times. For example, write-once fields could be implemented to only be write-protected if they have been set to value \"1\", wherein they would work as \"write-1-once\" and not \"write-once\".\u003c/xhtml:p\u003e\n            ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "284",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "Verilog"
      },
      {
        "prevalence": "Undetermined",
        "name": "VHDL"
      }
    ],
    "technology": [
      {
        "class": "System on Chip",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design"
    },
    {
      "phase": "Implementation",
      "note": [
        "Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases."
      ]
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Confidentiality",
        "Integrity",
        "Availability",
        "Access Control"
      ],
      "impact": [
        "Varies by Context"
      ],
      "note": "System configuration cannot be programmed in a secure way."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "During hardware design all register write-once or sticky fields must be evaluated for proper configuration."
      ]
    },
    {
      "phase": [
        "Testing"
      ],
      "description": [
        "The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n                    \u003cIntro_Text\u003eConsider the example design module system verilog code shown below. register_write_once_example module is an example of register that has a write-once field defined. Bit 0 field captures the write_once_status value. This implementation can be for a register that is defined by specification to be a write-once register, since the write_once_status field gets written by input data bit 0 on first write. \u003c/Intro_Text\u003e\n                    \u003cExample_Code Nature=\"bad\" Language=\"Verilog\"\u003e\n                        \u003cxhtml:div\u003emodule register_write_once_example \u003cxhtml:br/\u003e( \u003cxhtml:br/\u003einput [15:0] Data_in, \u003cxhtml:br/\u003einput Clk, \u003cxhtml:br/\u003einput ip_resetn, \u003cxhtml:br/\u003einput global_resetn, \u003cxhtml:br/\u003einput write, \u003cxhtml:br/\u003eoutput reg [15:0] Data_out \u003cxhtml:br/\u003e); \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003ereg Write_once_status; \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003ealways @(posedge Clk or negedge ip_resetn) \u003cxhtml:br/\u003e if (~ip_resetn) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out \u0026lt;= 16'h0000; \u003cxhtml:br/\u003e Write_once_status \u0026lt;= 1'b0; \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e else if (write \u0026amp; ~Write_once_status) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out \u0026lt;= Data_in \u0026amp; 16'hFFFE; \u003cxhtml:br/\u003e Write_once_status \u0026lt;= Data_in[0]; // Input bit 0 sets Write_once_status \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e else if (~write) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out[15:1] \u0026lt;= Data_out[15:1]; \u003cxhtml:br/\u003e Data_out[0] \u0026lt;= Write_once_status; \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003eendmodule \u003c/xhtml:div\u003e\n                    \u003c/Example_Code\u003e\n                    \u003cBody_Text\u003eThe above example only locks further writes if write_once_status bit is written to one. So it acts as write_1-Once instead of the write-once attribute.\u003c/Body_Text\u003e\n                    \u003cExample_Code Nature=\"informative\"\u003e\n                        \u003cxhtml:div\u003emodule register_write_once_example \u003cxhtml:br/\u003e( \u003cxhtml:br/\u003einput [15:0] Data_in, \u003cxhtml:br/\u003einput Clk, \u003cxhtml:br/\u003einput ip_resetn, \u003cxhtml:br/\u003einput global_resetn, \u003cxhtml:br/\u003einput write, \u003cxhtml:br/\u003eoutput reg [15:0] Data_out \u003cxhtml:br/\u003e); \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003ereg Write_once_status; \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003ealways @(posedge Clk or negedge ip_resetn) \u003cxhtml:br/\u003e if (~ip_resetn) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out \u0026lt;= 16'h0000; \u003cxhtml:br/\u003e Write_once_status \u0026lt;= 1'b0; \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e else if (write \u0026amp; ~Write_once_status) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out \u0026lt;= Data_in \u0026amp; 16'hFFFE; \u003cxhtml:br/\u003e Write_once_status \u0026lt;= 1'b1; // Write once status set on first write, independent of input \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e else if (~write) \u003cxhtml:br/\u003e begin \u003cxhtml:br/\u003e Data_out[15:1] \u0026lt;= Data_out[15:1]; \u003cxhtml:br/\u003e Data_out[0] \u0026lt;= Write_once_status; \u003cxhtml:br/\u003e end \u003cxhtml:br/\u003e\n                            \u003cxhtml:br/\u003eendmodule \u003c/xhtml:div\u003e\n                    \u003c/Example_Code\u003e\n                "
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi",
      "submission_organization": "Intel Corporation",
      "submission_date": "2019-12-12T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      }
    ]
  },
  "related_attack_patterns": [
    "680"
  ]
}
