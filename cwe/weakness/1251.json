{
  "id": "1251",
  "name": "Mirrored Regions with Different Values",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The product's architecture mirrors regions without ensuring that their contents always stay in sync.",
  "extended_description": "\n\t\t\t\t\u003cxhtml:p\u003eHaving mirrored regions with different values might result in the exposure of sensitive information or possibly system compromise.\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:p\u003eIn the interest of increased performance, one might need to duplicate a resource. A cache memory is a common example of this concept, which keeps a \"local\" copy of a data element in the high speed cache memory. Unfortunately, this speed improvement comes with a downside, since the product needs to ensure that the local copy always mirrors the original copy truthfully. If they get out of sync, the computational result is no longer true.\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:p\u003eDuring hardware design, memory is not the only item which gets mirrored. There are many other entities that get mirrored, as well: registers, memory regions, and, in some cases, even whole computational units. For example, within a multi-core processor, if all memory accesses for each and every core goes through a single Memory-Management Unit (MMU) then the MMU will become a performance bottleneck. In such cases, duplicating local MMUs that will serve only a subset of the cores rather than all of them may resolve the performance issue. These local copies are also called \"shadow copies\" or \"mirrored copies.\"\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:p\u003eIf the original resource never changed, local duplicate copies getting out of sync would never be an issue. However, the values of the original copy will sometimes change. When the original copy changes, the mirrored copies must also change, and change fast.\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:p\u003eThis situation of shadow-copy-possibly-out-of-sync-with-original-copy might occur as a result of multiple scenarios, including the following:\n\t\t\t\t\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n\t\t\t\t\t\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n\t\t\t\t\t\t\u003cxhtml:ul\u003e\n\t\t\t\t\t\t\t\u003cxhtml:li\u003eAfter the values in the original copy change, due to some reason the original copy does not send the \"update\" request to its shadow copies.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\u003cxhtml:li\u003eAfter the values in the original copy change, the original copy dutifully sends the \"update\" request to its shadow copies, but due to some reason the shadow copy does not \"execute\" this update request.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\u003cxhtml:li\u003eAfter the values in the original copy change, the original copy sends the \"update\" request to its shadow copies, and the shadow copy executes this update request faithfully. However, during the small time period when the original copy has \"new\" values and the shadow copy is still holding the \"old\" values, an attacker can exploit the old values. Then it becomes a race condition between the attacker and the update process of who can reach the target, shadow copy first, and, if the attacker reaches first, the attacker wins.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\u003cxhtml:li\u003eThe attacker might send a \"spoofed\" update request to the target shadow copy, pretending that this update request is coming from the original copy. This spoofed request might cause the targeted shadow copy to update its values to some attacker-friendly values, while the original copies remain unchanged by the attacker.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\u003cxhtml:li\u003eSuppose a situation where the original copy has a system of reverting back to its original value if it does not hear back from all the shadow copies that such copies have successfully completed the update request. In such a case, an attack might occur as follows: (1) the original copy might send an update request; (2) the shadow copy updates it; (3) the shadow copy sends back the successful completion message; (4) through a separate issue, the attacker is able to intercept the shadow copy's completion message. In this case, the original copy thinks that the update did not succeed, hence it reverts to its original value. Now there is a situation where the original copy has the \"old\" value, and the shadow copy has the \"new\" value.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\u003c/xhtml:ul\u003e\n\t\t\t\t\t\u003c/xhtml:div\u003e\n\t\t\t\t\u003c/xhtml:div\u003e\n\t\t\t",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "1250",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "VHDL"
      },
      {
        "prevalence": "Undetermined",
        "name": "Verilog"
      }
    ],
    "technology": [
      {
        "class": "System on Chip",
        "prevalence": "Undetermined"
      }
    ],
    "operating_system": [
      {
        "class": "OS-Independent",
        "prevalence": "Undetermined"
      }
    ],
    "architecture": [
      {
        "class": "Architecture-Independent",
        "prevalence": "Undetermined"
      }
    ]
  },
  "common_consequences": [
    {
      "scope": [
        "Confidentiality",
        "Integrity",
        "Availability",
        "Access Control",
        "Accountability",
        "Authentication",
        "Authorization",
        "Non-Repudiation"
      ],
      "impact": [
        "Varies by Context"
      ]
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "\n\t\t\t\t\t\t\u003cxhtml:p\u003eWhenever there are multiple, physically different copies of the same value that might change and the process to update them is not instantaneous and atomic, it is impossible to assert that the original and shadow copies will always be in sync - there will always be a time period when they are out of sync. To mitigate the consequential risk, the recommendations essentially are:\u003c/xhtml:p\u003e\n\t\t\t\t\t\t\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n\t\t\t\t\t\t\t\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n\t\t\t\t\t\t\t\t\u003cxhtml:ul\u003e\n\t\t\t\t\t\t\t\t\t\u003cxhtml:li\u003eMake this out-of-sync time period as small as possible, and\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\t\t\u003cxhtml:li\u003eMake the update process as robust as possible.\u003c/xhtml:li\u003e\n\t\t\t\t\t\t\t\t\u003c/xhtml:ul\u003e\n\t\t\t\t\t\t\t\u003c/xhtml:div\u003e\n\t\t\t\t\t\t\u003c/xhtml:div\u003e\n\t\t\t\t\t"
      ],
      "effectiveness": "Moderate"
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-132",
      "text": "\n\t\t\t\t\t\u003cIntro_Text\u003eSuppose a processor's Memory Management Unit (MMU) has 5 other shadow MMUs to distribute its workload for its various cores. Each MMU has the start address and end address of \"accessible\" memory. Any time this accessible range changes (as per the processor's boot status), the main MMU sends an update message to all the shadow MMUs.\u003c/Intro_Text\u003e\n\t\t\t\t\t\u003cBody_Text\u003eSuppose the interconnect fabric does not prioritize such \"update\" packets over other general traffic packets. This introduces a race condition. If an attacker can flood the target with enough messages so that some of those attack packets reach the target before the new access ranges gets updated, then the attacker can leverage this scenario.\u003c/Body_Text\u003e\n\t\t\t\t"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi",
      "submission_organization": "Intel Corporation",
      "submission_date": "2020-02-10T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Demonstrative_Examples, Description, Research_Gaps"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      }
    ]
  },
  "notes": [
    {
      "type": "Research Gap",
      "text": "Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.\n\t\t\t\t"
    }
  ]
}
