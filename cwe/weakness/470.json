{
  "id": "470",
  "name": "Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "The application uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.",
  "extended_description": "If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the application to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's classpath (CWE-427) or add new entries to the application's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the application.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "913",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "913",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "610",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "20",
      "view_id": "700",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "Java"
      },
      {
        "prevalence": "Undetermined",
        "name": "PHP"
      },
      {
        "class": "Interpreted",
        "prevalence": "Sometimes"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design"
    },
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability",
        "Other"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands",
        "Alter Execution Logic"
      ],
      "note": "The attacker might be able to execute code that is not directly accessible to the attacker. Alternately, the attacker could call unexpected code in the wrong place or the wrong time, possibly modifying critical system state."
    },
    {
      "scope": [
        "Availability",
        "Other"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart",
        "Other"
      ],
      "note": "The attacker might be able to use reflection to call the wrong code, possibly with unexpected arguments that violate the API (CWE-227). This could cause the application to exit or hang."
    },
    {
      "scope": [
        "Confidentiality"
      ],
      "impact": [
        "Read Application Data"
      ],
      "note": "By causing the wrong code to be invoked, the attacker might be able to trigger a runtime error that leaks sensitive information in the error message, such as CWE-536."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Refactor your code to avoid using reflection."
      ]
    },
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Do not use user-controlled inputs to select and load classes or code."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Apply strict input validation by using allowlists or indirect selection to ensure that the user is only selecting allowable classes or code."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eA common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"good\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eString ctl = request.getParameter(\"ctl\");\u003cxhtml:br/\u003eWorker ao = null;\u003cxhtml:br/\u003eif (ctl.equals(\"Add\")) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eao = new AddCommand();\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse if (ctl.equals(\"Modify\")) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eao = new ModifyCommand();\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse {\u003cxhtml:div style=\"margin-left:10px;\"\u003ethrow new UnknownActionError();\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eao.doAction(request);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eA programmer might refactor this code to use reflection as follows:\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eString ctl = request.getParameter(\"ctl\");\u003cxhtml:br/\u003eClass cmdClass = Class.forName(ctl + \"Command\");\u003cxhtml:br/\u003eWorker ao = (Worker) cmdClass.newInstance();\u003cxhtml:br/\u003eao.doAction(request);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher. However, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they do not modify the access control code, then some Worker classes will not have any access control.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eOne way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code follows:\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eString ctl = request.getParameter(\"ctl\");\u003cxhtml:br/\u003eClass cmdClass = Class.forName(ctl + \"Command\");\u003cxhtml:br/\u003eWorker ao = (Worker) cmdClass.newInstance();\u003cxhtml:br/\u003eao.checkAccessControl(request);\u003cxhtml:br/\u003eao.doAction(request);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eAlthough this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes. This code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple applications, in larger applications where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2004-2331",
      "description": "Database system allows attackers to bypass sandbox restrictions by using the Reflection APi.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2331"
    }
  ],
  "references": [
    {
      "reference_id": "REF-6",
      "author": [
        "Katrina Tsipenyuk",
        "Brian Chess",
        "Gary McGraw"
      ],
      "title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
      "url": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf",
      "publication_year": "2005",
      "publication_month": "--11",
      "publication_day": "---07",
      "publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
      "publisher": "NIST"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "7 Pernicious Kingdoms",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01T00:00:00Z",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Description, Relationships, Other_Notes, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-14T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Demonstrative_Examples, Description, Other_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-01-12T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Observed_Examples, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Name"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-02-21T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-10-28T00:00:00Z",
        "modification_comment": "updated Relationships"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Unsafe Reflection",
        "date": "2008-04-11T00:00:00Z"
      },
      {
        "text": "Use of Externally-Controlled Input to Select Classes or Code (aka 'Unsafe Reflection')",
        "date": "2009-05-27T00:00:00Z"
      }
    ]
  },
  "alternate_terms": [
    {
      "term": "Reflection Injection"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "7 Pernicious Kingdoms",
      "entry_name": "Unsafe Reflection"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Do not use reflection to increase accessibility of classes, methods, or fields",
      "entry_id": "SEC06-J"
    }
  ]
}
