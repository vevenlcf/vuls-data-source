{
  "id": "350",
  "name": "Reliance on Reverse DNS Resolution for a Security-Critical Action",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.",
  "extended_description": "\n            \u003cxhtml:p\u003eSince DNS names can be easily spoofed or misreported, and it may be difficult for the software to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eWhen the software performs a reverse DNS resolution for an IP address, if an attacker controls the server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eAttackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.\u003c/xhtml:p\u003e\n         ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "290",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "923",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "807",
      "view_id": "1000"
    },
    {
      "nature": "CanPrecede",
      "cweid": "923",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "class": "Language-Independent",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Access Control"
      ],
      "impact": [
        "Gain Privileges or Assume Identity",
        "Bypass Protection Mechanism"
      ],
      "note": "Malicious users can fake authentication information by providing false DNS information."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Use other means of identity verification that cannot be simply spoofed. Possibilities include a username/password or certificate."
      ]
    },
    {
      "mitigation_id": "MIT-42",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Perform proper forward and reverse DNS lookups to detect DNS spoofing."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-93",
      "text": "\n               \u003cIntro_Text\u003eThe following code samples use a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003estruct hostent *hp;struct in_addr myaddr;\u003cxhtml:br/\u003echar* tHost = \"trustme.example.com\";\u003cxhtml:br/\u003emyaddr.s_addr=inet_addr(ip_addr_string);\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003ehp = gethostbyaddr((char *) \u0026amp;myaddr, sizeof(struct in_addr), AF_INET);\u003cxhtml:br/\u003eif (hp \u0026amp;\u0026amp; !strncmp(hp-\u0026gt;h_name, tHost, sizeof(tHost))) {\u003cxhtml:div style=\"margin-left:10px;\"\u003etrusted = true;\u003c/xhtml:div\u003e} else {\u003cxhtml:div style=\"margin-left:10px;\"\u003etrusted = false;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eString ip = request.getRemoteAddr();\u003cxhtml:br/\u003eInetAddress addr = InetAddress.getByName(ip);\u003cxhtml:br/\u003eif (addr.getCanonicalHostName().endsWith(\"trustme.com\")) {\u003cxhtml:div style=\"margin-left:10px;\"\u003etrusted = true;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C#\"\u003e\n                  \u003cxhtml:div\u003eIPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);\u003cxhtml:br/\u003eIPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);\u003cxhtml:br/\u003eif (hostInfo.HostName.EndsWith(\"trustme.com\")) {\u003cxhtml:div style=\"margin-left:10px;\"\u003etrusted = true;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eIn these examples, a connection is established if a request is made by a trusted host.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003esd = socket(AF_INET, SOCK_DGRAM, 0);\u003cxhtml:br/\u003eserv.sin_family = AF_INET;\u003cxhtml:br/\u003eserv.sin_addr.s_addr = htonl(INADDR_ANY);\u003cxhtml:br/\u003eservr.sin_port = htons(1008);\u003cxhtml:br/\u003ebind(sd, (struct sockaddr *) \u0026amp; serv, sizeof(serv));\u003cxhtml:br/\u003ewhile (1) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e\n                           \u003cxhtml:br/\u003ememset(msg, 0x0, MAX_MSG);\u003cxhtml:br/\u003eclilen = sizeof(cli);\u003cxhtml:br/\u003eh=gethostbyname(inet_ntoa(cliAddr.sin_addr));\u003cxhtml:br/\u003eif (h-\u0026gt;h_name==...) n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) \u0026amp; cli, \u0026amp;clilen);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003ewhile(true) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eDatagramPacket rp=new DatagramPacket(rData,rData.length);\u003cxhtml:br/\u003eoutSock.receive(rp);\u003cxhtml:br/\u003eString in = new String(p.getData(),0, rp.getLength());\u003cxhtml:br/\u003eInetAddress IPAddress = rp.getAddress();\u003cxhtml:br/\u003eint port = rp.getPort();\u003cxhtml:br/\u003eif ((rp.getHostName()==...) \u0026amp; (in==...)) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003e\n                                 \u003cxhtml:br/\u003eout = secret.getBytes();\u003cxhtml:br/\u003eDatagramPacket sp =new DatagramPacket(out,out.length, IPAddress, port);\u003cxhtml:br/\u003eoutSock.send(sp);\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThese examples check if a request is from a trusted host before responding to a request, but the code only verifies the hostname as stored in the request packet. An attacker can spoof the hostname, thus impersonating a trusted client.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2001-1488",
      "description": "Does not do double-reverse lookup to prevent DNS spoofing.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1488"
    },
    {
      "reference": "CVE-2001-1500",
      "description": "Does not verify reverse-resolved hostnames in DNS.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1500"
    },
    {
      "reference": "CVE-2000-1221",
      "description": "Authentication bypass using spoofed reverse-resolved DNS hostnames.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1221"
    },
    {
      "reference": "CVE-2002-0804",
      "description": "Authentication bypass using spoofed reverse-resolved DNS hostnames.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0804"
    },
    {
      "reference": "CVE-2001-1155",
      "description": "Filter does not properly check the result of a reverse DNS lookup, which could allow remote attackers to bypass intended access restrictions via DNS spoofing.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-1155"
    },
    {
      "reference": "CVE-2004-0892",
      "description": "Reverse DNS lookup used to spoof trusted content in intermediary.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0892"
    },
    {
      "reference": "CVE-2003-0981",
      "description": "Product records the reverse DNS name of a visitor in the logs, allowing spoofing and resultant XSS.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0981"
    }
  ],
  "references": [
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    },
    {
      "section": "\"Sin 15: Not Updating Easily.\" Page 231",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "section": "\"Sin 24: Trusting Network Name Resolution.\" Page 361",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "section": "Chapter 16, \"DNS Spoofing\", Page 1002",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Sean Eidemiller",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "added/updated demonstrative examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-06-23T00:00:00Z",
        "modification_comment": "CWE-247 and CWE-292 deprecated and merged into CWE-350 to address duplicates.",
        "modification_importance": "Critical"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-07-17T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Description, Maintenance_Notes, Name, Potential_Mitigations, References, Relationships, Taxonomy_Mappings, Type"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Description, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-05-03T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Improperly Trusted Reverse DNS",
        "date": "2013-07-17T00:00:00Z"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Improperly Trusted Reverse DNS"
    },
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Trusting self-reported DNS name"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty endpoint authentication",
      "entry_id": "SFP29"
    }
  ],
  "related_attack_patterns": [
    "142",
    "275",
    "73",
    "89"
  ],
  "notes": [
    {
      "type": "Maintenance",
      "text": "CWE-350, CWE-247, and CWE-292 were merged into CWE-350 in CWE 2.5. CWE-247 was originally derived from Seven Pernicious Kingdoms, CWE-350 from PLOVER, and CWE-292 from CLASP. All taxonomies focused closely on the use of reverse DNS for authentication of incoming requests."
    }
  ]
}
