{
  "id": "831",
  "name": "Signal Handler Function Associated with Multiple Signals",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The software defines a function that is used as a handler for more than one signal.",
  "extended_description": "\n            \u003cxhtml:p\u003eWhile sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eAn attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eAnother rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.\u003c/xhtml:p\u003e\n         ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "364",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {},
  "common_consequences": [
    {
      "scope": [
        "Availability",
        "Integrity",
        "Confidentiality",
        "Access Control",
        "Other"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart",
        "Execute Unauthorized Code or Commands",
        "Read Application Data",
        "Gain Privileges or Assume Identity",
        "Bypass Protection Mechanism",
        "Varies by Context"
      ],
      "note": "The most common consequence will be a corruption of the state of the software, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure."
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThis code registers the same signal handler function with two different signals.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003evoid handler (int sigNum) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e...\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eint main (int argc, char* argv[]) {\u003cxhtml:div style=\"margin-left:10px;\"\u003esignal(SIGUSR1, handler)\u003cxhtml:br/\u003esignal(SIGUSR2, handler)\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-26",
      "text": "\n               \u003cIntro_Text\u003eThis code registers the same signal handler function with two different signals (CWE-831). If those signals are sent to the process, the handler creates a log message (specified in the first argument to the program) and exits.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar *logMessage;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003evoid handler (int sigNum) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003esyslog(LOG_NOTICE, \"%s\\n\", logMessage);\u003cxhtml:br/\u003efree(logMessage);\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003esleep(10);\u003cxhtml:br/\u003eexit(0);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eint main (int argc, char* argv[]) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003elogMessage = strdup(argv[1]);\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* Register signal handlers. */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003esignal(SIGHUP, handler);\u003cxhtml:br/\u003esignal(SIGTERM, handler);\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* artificially increase the size of the timing window to make demonstration of this weakness easier. */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003esleep(10);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe handler function uses global state (globalVar and logMessage), and it can be called by both the SIGHUP and SIGTERM signals. An attack scenario might follow these lines:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:ul\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eThe program begins execution, initializes logMessage, and registers the signal handlers for SIGHUP and SIGTERM.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eThe program begins its \"normal\" functionality, which is simplified as sleep(), but could be any functionality that consumes some time.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eThe attacker sends SIGHUP, which invokes handler (call this \"SIGHUP-handler\").\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eSIGHUP-handler begins to execute, calling syslog().\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003esyslog() calls malloc(), which is non-reentrant. malloc() begins to modify metadata to manage the heap.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eThe attacker then sends SIGTERM.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eSIGHUP-handler is interrupted, but syslog's malloc call is still executing and has not finished modifying its metadata.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eThe SIGTERM handler is invoked.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                     \u003cxhtml:li\u003e\n                        \u003cxhtml:div\u003eSIGTERM-handler records the log message using syslog(), then frees the logMessage variable.\u003c/xhtml:div\u003e\n                     \u003c/xhtml:li\u003e\n                  \u003c/xhtml:ul\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003eAt this point, the state of the heap is uncertain, because malloc is still modifying the metadata for the heap; the metadata might be in an inconsistent state. The SIGTERM-handler call to free() is assuming that the metadata is inconsistent, possibly causing it to write data to the wrong location while managing the heap. The result is memory corruption, which could lead to a crash or even code execution, depending on the circumstances under which the code is running.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eNote that this is an adaptation of a classic example as originally presented by Michal Zalewski [REF-360]; the original example was shown to be exploitable for code execution.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eAlso note that the strdup(argv[1]) call contains a potential buffer over-read (CWE-126) if the program is called without any arguments, because argc would be 0, and argv[1] would point outside the bounds of the array.\u003c/Body_Text\u003e\n            "
    }
  ],
  "references": [
    {
      "reference_id": "REF-360",
      "author": [
        "Michal Zalewski"
      ],
      "title": "Delivering Signals for Fun and Profit",
      "url": "http://lcamtuf.coredump.cx/signals.txt"
    },
    {
      "reference_id": "REF-361",
      "title": "Race Condition: Signal Handling",
      "url": "http://www.fortify.com/vulncat/en/vulncat/cpp/race_condition_signal_handling.html"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2010-12-12T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      }
    ]
  }
}
