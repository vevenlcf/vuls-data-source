{
  "id": "1335",
  "name": "Incorrect Bitwise Shift of Integer",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result.",
  "extended_description": "\n\t\t\t\t\u003cxhtml:p\u003eSpecifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue.\u003c/xhtml:p\u003e\n\t\t\t\t\u003cxhtml:p\u003eSpecifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result.\u003c/xhtml:p\u003e\n\t\t\t",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "prevalence": "Undetermined",
        "name": "C#"
      },
      {
        "prevalence": "Undetermined",
        "name": "Java"
      },
      {
        "prevalence": "Undetermined",
        "name": "JavaScript"
      }
    ],
    "technology": [
      {
        "class": "Technology-Independent",
        "prevalence": "Undetermined"
      }
    ],
    "operating_system": [
      {
        "class": "OS-Independent",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation",
      "note": [
        "Adding shifts without properly verifying the size and sign of the shift amount."
      ]
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Integrity"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart"
      ]
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Implicitly or explicitly add checks and mitigation for negative or over-shift values."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n\t\t\t\t\t\u003cIntro_Text\u003e\n\t\t\t\t\t\tA negative shift amount for an x86 or x86_64 shift instruction will produce the number of bits to be shifted by taking a 2's-complement of the shift amount and effectively masking that amount to the lowest 6 bits for a 64 bit shift instruction.\n\t\t\t\t\t\u003c/Intro_Text\u003e\n\t\t\t\t\t\u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n\t\t\t\t\tunsigned int r = 1 \u0026lt;\u0026lt; -5;\n\t\t\t\t\t\u003c/Example_Code\u003e\n\t\t\t\t\t\u003cBody_Text\u003eThe example above ends up with a shift amount of -5. The hexadecimal value is FFFFFFFFFFFFFFFD which, when bits above the  6th bit are masked off, the shift amount becomes a binary shift value of 111101 which is 61 decimal. A shift of 61 produces a very different result than -5. The previous example is a very simple version of the following code which is probably more realistic of what happens in a real system.\u003c/Body_Text\u003e\n\t\t\t\t\t\u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n\t\t\t\t\t\tint choose_bit(int reg_bit, int bit_number_from_elsewhere) \u003cxhtml:br/\u003e\n\t\t\t\t\t\t{\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  if (NEED_TO_SHIFT)\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  {\u003cxhtml:br/\u003e\n\t\t\t\t\t\t    reg_bit -= bit_number_from_elsewhere;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  }\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  return reg_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t}\u003cxhtml:br/\u003e\n\t\t\t\t\t\tunsigned int handle_io_register(unsigned int *r)\u003cxhtml:br/\u003e\n\t\t\t\t\t\t{\u003cxhtml:br/\u003e\n\t\t\t\t\t\t\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  unsigned int the_bit = 1 \u0026lt;\u0026lt; choose_bit(5, 10);\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  *r |= the_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  return the_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t}\n\t\t\t\t\t\u003c/Example_Code\u003e\n\t\t\t\t\t\u003cExample_Code Nature=\"good\" Language=\"C\"\u003e\n\t\t\t\t\t\tint choose_bit(int reg_bit, int bit_number_from_elsewhere) \u003cxhtml:br/\u003e\n\t\t\t\t\t\t{\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  if (NEED_TO_SHIFT)\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  {\u003cxhtml:br/\u003e\n\t\t\t\t\t\t    reg_bit -= bit_number_from_elsewhere;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  }\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  return reg_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t}\u003cxhtml:br/\u003e\n\t\t\t\t\t\t\u003cxhtml:br/\u003e\n\t\t\t\t\t\tunsigned int handle_io_register(unsigned int *r)\u003cxhtml:br/\u003e\n\t\t\t\t\t\t{\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  int the_bit_number = choose_bit(5, 10);\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  if ((the_bit_number \u0026gt; 0) \u0026amp;\u0026amp; (the_bit_number \u0026lt; 63))\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  {\u003cxhtml:br/\u003e\n\t\t\t\t\t\t    unsigned int the_bit = 1 \u0026lt;\u0026lt; the_bit_number;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t    *r |= the_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  }\u003cxhtml:br/\u003e\n\t\t\t\t\t\t  return the_bit;\u003cxhtml:br/\u003e\n\t\t\t\t\t\t}\n\t\t\t\t\t\u003c/Example_Code\u003e\n\t\t\t\t\t\u003cBody_Text\u003eNote that the good example not only checks for negative shifts and disallows them but also for over-shifts. Not bit operation is done if the shift is out of bounds. Depending on the program, perhaps an error message should be logged.\u003c/Body_Text\u003e\n\t\t\t\t"
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2009-4307",
      "description": "An unexpected large value in the ext4 filesystem causes an overshift condition resulting in a divide by zero.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4307"
    },
    {
      "reference": "CVE-2012-2100",
      "description": "An unexpected large value in the ext4 filesystem causes an overshift condition resulting in a divide by zero - fix of CVE-2009-4307.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2100"
    },
    {
      "reference": "CVE-2020-8835",
      "description": "An overshift in a kernel a allowed out of bounds reads and writes resulting in a root takeover.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8835"
    },
    {
      "reference": "CVE-2015-1607",
      "description": "Program is  not properly handling signed bitwise left-shifts causing an overlapping memcpy memory range error.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1607"
    },
    {
      "reference": "CVE-2016-9842",
      "description": "Compression function improperly executes a signed left shift of a negative integer.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-9842"
    },
    {
      "reference": "CVE-2018-18445",
      "description": "Some kernels improperly handle right shifts of 32 bit numbers in a 64 bit register.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-18445"
    },
    {
      "reference": "CVE-2013-4206",
      "description": "Putty  has an incorrectly sized shift value resulting in an overshift.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-4206"
    },
    {
      "reference": "CVE-2018-20788",
      "description": "LED driver overshifts under certain conditions resulting in a DoS.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20788"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2021-03-29T00:00:00Z"
    }
  }
}
