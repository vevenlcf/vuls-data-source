{
  "id": "788",
  "name": "Access of Memory Location After End of Buffer",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The software reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
  "extended_description": "This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1340",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {},
  "common_consequences": [
    {
      "scope": [
        "Confidentiality"
      ],
      "impact": [
        "Read Memory"
      ],
      "note": "For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
    },
    {
      "scope": [
        "Integrity",
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "DoS: Crash, Exit, or Restart"
      ],
      "note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
    },
    {
      "scope": [
        "Integrity"
      ],
      "impact": [
        "Modify Memory",
        "Execute Unauthorized Code or Commands"
      ],
      "note": "If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator."
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-1",
      "text": "\n               \u003cIntro_Text\u003eThis example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003evoid host_lookup(char *user_supplied_addr){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003estruct hostent *hp;\u003cxhtml:br/\u003ein_addr_t *addr;\u003cxhtml:br/\u003echar hostname[64];\u003cxhtml:br/\u003ein_addr_t inet_addr(const char *cp);\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/*routine that ensures user_supplied_addr is in the right format for conversion */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003evalidate_addr_form(user_supplied_addr);\u003cxhtml:br/\u003eaddr = inet_addr(user_supplied_addr);\u003cxhtml:br/\u003ehp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\u003cxhtml:br/\u003estrcpy(hostname, hp-\u0026gt;h_name);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThis function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eNote that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476).\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-114",
      "text": "\n               \u003cIntro_Text\u003eIn the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint returnChunkSize(void *) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* if chunk info is valid, return the size of usable memory,\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e* else, return -1 to indicate an error\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e*/\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eint main() {\u003cxhtml:div style=\"margin-left:10px;\"\u003e...\u003cxhtml:br/\u003ememcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788).\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-19",
      "text": "\n               \u003cIntro_Text\u003eThis example applies an encoding procedure to an input string and stores it into a buffer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar * copy_input(char *user_supplied_string){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint i, dst_index;\u003cxhtml:br/\u003echar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\u003cxhtml:br/\u003eif ( MAX_SIZE \u0026lt;= strlen(user_supplied_string) ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edie(\"user string too long, die evil hacker!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003edst_index = 0;\u003cxhtml:br/\u003efor ( i = 0; i \u0026lt; strlen(user_supplied_string); i++ ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003eif( '\u0026amp;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edst_buf[dst_index++] = '\u0026amp;';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'a';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'm';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'p';\u003cxhtml:br/\u003edst_buf[dst_index++] = ';';\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse if ('\u0026lt;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                                    \u003cxhtml:div\u003e\n                                       \u003cxhtml:br/\u003e\n                                       \u003cxhtml:i\u003e/* encode to \u0026amp;lt; */\u003c/xhtml:i\u003e\n                                       \u003cxhtml:br/\u003e\n                                    \u003c/xhtml:div\u003e\n                                 \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse dst_buf[dst_index++] = user_supplied_string[i];\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn dst_buf;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-91",
      "text": "\n               \u003cIntro_Text\u003eIn the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint processMessageFromSocket(int socket) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint success;\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003echar buffer[BUFFER_SIZE];\u003cxhtml:br/\u003echar message[MESSAGE_SIZE];\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e// get message from socket and store into buffer\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e//Ignoring possibliity that buffer \u0026gt; BUFFER_SIZE\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003eif (getMessage(socket, buffer, BUFFER_SIZE) \u0026gt; 0) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// place contents of the buffer into message structure\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003eExMessage *msg = recastBuffer(buffer);\u003cxhtml:br/\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// copy message body into string for processing\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003eint index;\u003cxhtml:br/\u003efor (index = 0; index \u0026lt; msg-\u0026gt;msgLength; index++) {\u003cxhtml:div style=\"margin-left:10px;\"\u003emessage[index] = msg-\u0026gt;msgBody[index];\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003emessage[index] = '\\0';\u003cxhtml:br/\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e// process message\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003esuccess = processMessage(message);\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn success;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130).\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2009-2550",
      "description": "Classic stack-based buffer overflow in media player using a long entry in a playlist",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550"
    },
    {
      "reference": "CVE-2009-2403",
      "description": "Heap-based buffer overflow in media player using a long entry in a playlist",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403"
    },
    {
      "reference": "CVE-2009-0689",
      "description": "large precision value in a format string triggers overflow",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689"
    },
    {
      "reference": "CVE-2009-0558",
      "description": "attacker-controlled array index leads to code execution",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558"
    },
    {
      "reference": "CVE-2008-4113",
      "description": "OS kernel trusts userland-supplied length value, allowing reading of sensitive information",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113"
    },
    {
      "reference": "CVE-2007-4268",
      "description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4268"
    }
  ],
  "references": [
    {
      "section": "ASCRM-CWE-788",
      "reference_id": "REF-961",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Reliability Measure (ASCRM)",
      "url": "http://www.omg.org/spec/ASCRM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2009-10-21T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Observed_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-02-21T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2015-12-07T00:00:00Z",
        "modification_comment": "updated Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-05-03T00:00:00Z",
        "modification_comment": "updated Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Observed_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-07-20T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Description"
      }
    ],
    "contribution": [
      {
        "type": "Feedback",
        "contribution_name": "Eric Constantin Brinz",
        "contribution_organization": "GENIA-SEC IT-Sicherheitsmanagement GmbH",
        "contribution_date": "2022-02-23T00:00:00Z",
        "contribution_comment": "Suggested corrections to extended description."
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "OMG ASCRM",
      "entry_id": "ASCRM-CWE-788"
    }
  ]
}
