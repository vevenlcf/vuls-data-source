{
  "id": "122",
  "name": "Heap-based Buffer Overflow",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Draft",
  "description": "A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "788",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "787",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design"
    },
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "High",
  "common_consequences": [
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart",
        "DoS: Resource Consumption (CPU)",
        "DoS: Resource Consumption (Memory)"
      ],
      "note": "Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
    },
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability",
        "Access Control"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands",
        "Bypass Protection Mechanism",
        "Modify Memory"
      ],
      "note": "Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime."
    },
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability",
        "Access Control",
        "Other"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands",
        "Bypass Protection Mechanism",
        "Other"
      ],
      "note": "When the consequence is arbitrary code execution, this can often be used to subvert any other security service."
    }
  ],
  "potential_mitigations": [
    {
      "description": [
        "Pre-design: Use a language or compiler that performs automatic bounds checking."
      ]
    },
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Use an abstraction library to abstract away risky APIs. Not a complete solution."
      ]
    },
    {
      "phase": [
        "Build and Compilation"
      ],
      "description": [
        "Pre-design through Build: Canary style bounds checking, library changes which ensure the validity of chunk data, and other such fixes are possible, but should not be relied upon."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Implement and perform bounds checking on input."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary."
      ],
      "strategy": "Libraries or Frameworks"
    },
    {
      "phase": [
        "Operation"
      ],
      "description": [
        "Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eWhile buffer overflow examples can be rather complex, it is possible to have very simple, yet still exploitable, heap-based buffer overflows:\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e#define BUFSIZE 256\u003cxhtml:br/\u003eint main(int argc, char **argv) {\u003cxhtml:div style=\"margin-left:10px;\"\u003echar *buf;\u003cxhtml:br/\u003ebuf = (char *)malloc(sizeof(char)*BUFSIZE);\u003cxhtml:br/\u003estrcpy(buf, argv[1]);\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe buffer is allocated heap memory with a fixed size, but there is no guarantee the string in argv[1] will not exceed this size and cause an overflow.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-19",
      "text": "\n               \u003cIntro_Text\u003eThis example applies an encoding procedure to an input string and stores it into a buffer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar * copy_input(char *user_supplied_string){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint i, dst_index;\u003cxhtml:br/\u003echar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\u003cxhtml:br/\u003eif ( MAX_SIZE \u0026lt;= strlen(user_supplied_string) ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edie(\"user string too long, die evil hacker!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003edst_index = 0;\u003cxhtml:br/\u003efor ( i = 0; i \u0026lt; strlen(user_supplied_string); i++ ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003eif( '\u0026amp;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003edst_buf[dst_index++] = '\u0026amp;';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'a';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'm';\u003cxhtml:br/\u003edst_buf[dst_index++] = 'p';\u003cxhtml:br/\u003edst_buf[dst_index++] = ';';\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse if ('\u0026lt;' == user_supplied_string[i] ){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                                    \u003cxhtml:div\u003e\n                                       \u003cxhtml:br/\u003e\n                                       \u003cxhtml:i\u003e/* encode to \u0026amp;lt; */\u003c/xhtml:i\u003e\n                                       \u003cxhtml:br/\u003e\n                                    \u003c/xhtml:div\u003e\n                                 \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse dst_buf[dst_index++] = user_supplied_string[i];\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn dst_buf;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2007-4268",
      "description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4268"
    },
    {
      "reference": "CVE-2009-2523",
      "description": "Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2523"
    },
    {
      "reference": "CVE-2021-29529",
      "description": "Chain: machine-learning product can have a heap-based\n\t      buffer overflow (CWE-122) when some integer-oriented bounds are\n\t      calculated by using ceiling() and floor() on floating point values\n\t      (CWE-1339)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29529"
    }
  ],
  "references": [
    {
      "section": "Chapter 5, \"Heap Overruns\" Page 138",
      "reference_id": "REF-7",
      "author": [
        "Michael Howard",
        "David LeBlanc"
      ],
      "title": "Writing Secure Code",
      "url": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223",
      "publication_year": "2002",
      "publication_month": "--12",
      "publication_day": "---04",
      "publisher": "Microsoft Press",
      "edition": "2nd Edition"
    },
    {
      "section": "\"Sin 5: Buffer Overruns.\" Page 89",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "section": "Chapter 3, \"Nonexecutable Stack\", Page 76",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "Chapter 5, \"Protection Mechanisms\", Page 189",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CLASP",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01T00:00:00Z",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Other_Notes, Relationship_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-01-12T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2013-02-21T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Observed_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Causal_Nature, Likelihood_of_Exploit, Observed_Examples, References, Relationships, Taxonomy_Mappings, White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-07-20T00:00:00Z",
        "modification_comment": "updated Observed_Examples"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Primary"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Heap overflow"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Buffer Access",
      "entry_id": "SFP8"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
      "entry_id": "STR31-C",
      "mapping_fit": "CWE More Specific"
    }
  ],
  "related_attack_patterns": [
    "92"
  ],
  "notes": [
    {
      "type": "Relationship",
      "text": "Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows."
    }
  ],
  "affected_resources": [
    "Memory"
  ]
}
