{
  "id": "667",
  "name": "Improper Locking",
  "abstraction": "Class",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.",
  "extended_description": "\n\t   \u003cxhtml:p\u003eLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process.  This can lead to data or memory corruption, denial of service, etc.\u003c/xhtml:p\u003e",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "662",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "662",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "662",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "662",
      "view_id": "1340",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {},
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design"
    },
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "DoS: Resource Consumption (CPU)"
      ],
      "note": "Inconsistent locking discipline can lead to deadlock."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Use industry standard APIs to implement locking mechanism."
      ],
      "strategy": "Libraries or Frameworks"
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eIn the following Java snippet, methods are defined to get and set a long field in an instance of a class that is shared across multiple threads. Because operations on double and long are nonatomic in Java, concurrent access may cause unexpected behavior. Thus, all operations on long and double fields should be synchronized.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eprivate long someLongValue;\u003cxhtml:br/\u003epublic long getLongValue() {\u003cxhtml:div style=\"margin-left:10px;\"\u003ereturn someLongValue;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003epublic void setLongValue(long l) {\u003cxhtml:div style=\"margin-left:10px;\"\u003esomeLongValue = l;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-69",
      "text": "\n               \u003cIntro_Text\u003eThis code tries to obtain a lock for a file, then writes to it.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"PHP\"\u003e\n                  \u003cxhtml:div\u003efunction writeToLog($message){\u003cxhtml:div style=\"margin-left:10px;\"\u003e$logfile = fopen(\"logFile.log\", \"a\");\u003cxhtml:br/\u003e\n                        \u003cxhtml:i\u003e//attempt to get logfile lock\u003c/xhtml:i\u003e\n                        \u003cxhtml:br/\u003eif (flock($logfile, LOCK_EX)) {\u003cxhtml:div style=\"margin-left:10px;\"\u003efwrite($logfile,$message);\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e// unlock logfile\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003eflock($logfile, LOCK_UN);\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse {\u003cxhtml:div style=\"margin-left:10px;\"\u003eprint \"Could not obtain lock on logFile.log, message not recorded\\n\";\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003efclose($logFile);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003ePHP by default will wait indefinitely until a file lock is released. If an attacker is able to obtain the file lock, this code will pause execution, possibly leading to denial of service for other users. Note that in this case, if an attacker can perform an flock() on the file, they may already have privileges to destroy the log file. However, this still impacts the execution of other programs that depend on flock().\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-24",
      "text": "\n               \u003cIntro_Text\u003eThe following function attempts to acquire a lock in order to perform operations on a shared resource.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003evoid f(pthread_mutex_t *mutex) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003epthread_mutex_lock(mutex);\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* access shared resource */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003epthread_mutex_unlock(mutex);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eIn order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels.\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"good\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint f(pthread_mutex_t *mutex) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eint result;\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003eresult = pthread_mutex_lock(mutex);\u003cxhtml:br/\u003eif (0 != result)\u003cxhtml:div style=\"margin-left:10px;\"\u003ereturn result;\u003c/xhtml:div\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* access shared resource */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003ereturn pthread_mutex_unlock(mutex);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-70",
      "text": "\n               \u003cIntro_Text\u003eIt may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization...\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eif (helper == null) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003esynchronized (this) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eif (helper == null) {\u003cxhtml:div style=\"margin-left:10px;\"\u003ehelper = new Helper();\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn helper;\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe programmer wants to guarantee that only one Helper() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eSuppose that helper is not initialized. Then, thread A sees that helper==null and enters the synchronized block and begins to execute:\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"bad\"\u003e\n                  \u003cxhtml:div\u003ehelper = new Helper();\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf a second thread, thread B, takes over in the middle of this call and helper has not finished running the constructor, then thread B may make calls on helper while its fields hold incorrect values.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2021-1782",
      "description": "Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-1782"
    },
    {
      "reference": "CVE-2009-0935",
      "description": "Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0935"
    },
    {
      "reference": "CVE-2010-4210",
      "description": "function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4210"
    },
    {
      "reference": "CVE-2008-4302",
      "description": "Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4302"
    },
    {
      "reference": "CVE-2009-1243",
      "description": "OS kernel performs an unlock in some incorrect circumstances, leading to panic.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1243"
    },
    {
      "reference": "CVE-2009-2857",
      "description": "OS deadlock",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2857"
    },
    {
      "reference": "CVE-2009-1961",
      "description": "OS deadlock involving 3 separate functions",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1961"
    },
    {
      "reference": "CVE-2009-2699",
      "description": "deadlock in library",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2699"
    },
    {
      "reference": "CVE-2009-4272",
      "description": "deadlock triggered by packets that force collisions in a routing table",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4272"
    },
    {
      "reference": "CVE-2002-1850",
      "description": "read/write deadlock between web server and script",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1850"
    },
    {
      "reference": "CVE-2004-0174",
      "description": "web server deadlock involving multiple listening connections",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0174"
    },
    {
      "reference": "CVE-2009-1388",
      "description": "multiple simultaneous calls to the same function trigger deadlock.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1388"
    },
    {
      "reference": "CVE-2006-5158",
      "description": "chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5158"
    },
    {
      "reference": "CVE-2006-4342",
      "description": "deadlock when an operation is performed on a resource while it is being removed.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4342"
    },
    {
      "reference": "CVE-2006-2374",
      "description": "Deadlock in device driver triggered by using file handle of a related device.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2374"
    },
    {
      "reference": "CVE-2006-2275",
      "description": "Deadlock when large number of small messages cannot be processed quickly enough.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2275"
    },
    {
      "reference": "CVE-2005-3847",
      "description": "OS kernel has deadlock triggered by a signal during a core dump.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3847"
    },
    {
      "reference": "CVE-2005-3106",
      "description": "Race condition leads to deadlock.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3106"
    },
    {
      "reference": "CVE-2005-2456",
      "description": "Chain: array index error (CWE-129) leads to deadlock (CWE-833)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2456"
    },
    {
      "reference": "CVE-2001-0682",
      "description": "Program can not execute when attacker obtains a mutex.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0682"
    },
    {
      "reference": "CVE-2002-1914",
      "description": "Program can not execute when attacker obtains a lock on a critical output file.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1914"
    },
    {
      "reference": "CVE-2002-1915",
      "description": "Program can not execute when attacker obtains a lock on a critical output file.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1915"
    },
    {
      "reference": "CVE-2002-0051",
      "description": "Critical file can be opened with exclusive read access by user, preventing application of security policy. Possibly related to improper permissions, large-window race condition.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0051"
    },
    {
      "reference": "CVE-2000-0338",
      "description": "Chain: predictable file names used for locking, allowing attacker to create the lock beforehand. Resultant from permissions and randomness.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-0338"
    },
    {
      "reference": "CVE-2000-1198",
      "description": "Chain: Lock files with predictable names. Resultant from randomness.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2000-1198"
    },
    {
      "reference": "CVE-2002-1869",
      "description": "Product does not check if it can write to a log file, allowing attackers to avoid logging by accessing the file using an exclusive lock. Overlaps unchecked error condition. This is not quite CWE-412, but close.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1869"
    }
  ],
  "references": [
    {
      "section": "ASCSM-CWE-667",
      "reference_id": "REF-962",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Security Measure (ASCSM)",
      "url": "http://www.omg.org/spec/ASCSM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2008-04-11T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Sean Eidemiller",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "added/updated demonstrative examples"
      },
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Time_of_Introduction"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-03-10T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-07-27T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-12-13T00:00:00Z",
        "modification_comment": "updated Description, Name, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Observed_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-05-03T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-09-19T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-09-23T00:00:00Z",
        "modification_comment": "updated Description, Maintenance_Notes, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships, Type"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-06-28T00:00:00Z",
        "modification_comment": "updated Observed_Examples"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Insufficient Locking",
        "date": "2010-12-13T00:00:00Z"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Do not destroy a mutex while it is locked",
      "entry_id": "CON31-C",
      "mapping_fit": "CWE More Abstract"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Do not unlock or destroy another POSIX thread's mutex",
      "entry_id": "POS48-C",
      "mapping_fit": "CWE More Abstract"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Ensure visibility when accessing shared primitive variables",
      "entry_id": "VNA00-J"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Ensure that compound operations on shared variables are atomic",
      "entry_id": "VNA02-J"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Ensure atomicity when reading and writing 64-bit values",
      "entry_id": "VNA05-J"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Do not use an instance lock to protect shared static data",
      "entry_id": "LCK06-J"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Missing Lock",
      "entry_id": "SFP19"
    },
    {
      "taxonomy_name": "OMG ASCSM",
      "entry_id": "ASCSM-CWE-667"
    }
  ],
  "related_attack_patterns": [
    "25",
    "26",
    "27"
  ],
  "notes": [
    {
      "type": "Maintenance",
      "text": "Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc.  CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."
    }
  ]
}
