{
  "id": "469",
  "name": "Use of Pointer Subtraction to Determine Size",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "The application subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "Medium",
  "common_consequences": [
    {
      "scope": [
        "Access Control",
        "Integrity",
        "Confidentiality",
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "Read Memory",
        "Execute Unauthorized Code or Commands",
        "Gain Privileges or Assume Identity"
      ],
      "note": "There is the potential for arbitrary code execution with privileges of the vulnerable program."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Save an index variable. This is the recommended solution. Rather than subtract pointers from one another, use an index variable of the same size as the pointers in question. Use this variable to \"walk\" from one pointer to the other and calculate the difference. Always validate this number."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThe following example contains the method size that is used to determine the number of nodes in a linked list. The method is passed a pointer to the head of the linked list.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003estruct node {\u003cxhtml:div style=\"margin-left:10px;\"\u003eint data;\u003cxhtml:br/\u003estruct node* next;\u003c/xhtml:div\u003e};\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e// Returns the number of nodes in a linked list from\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e// the given pointer to the head of the list.\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003eint size(struct node* head) {\u003cxhtml:div style=\"margin-left:10px;\"\u003estruct node* current = head;\u003cxhtml:br/\u003estruct node* tail;\u003cxhtml:br/\u003ewhile (current != NULL) {\u003cxhtml:div style=\"margin-left:10px;\"\u003etail = current;\u003cxhtml:br/\u003ecurrent = current-\u0026gt;next;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn tail - head;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e// other methods for manipulating the list\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eHowever, the method creates a pointer that points to the end of the list and uses pointer subtraction to determine the number of nodes in the list by subtracting the tail pointer from the head pointer. There no guarantee that the pointers exist in the same memory area, therefore using pointer subtraction in this way could return incorrect results and allow other unintended behavior. In this example a counter should be used to determine the number of nodes in the list, as shown in the following code.\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"good\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eint size(struct node* head) {\u003cxhtml:div style=\"margin-left:10px;\"\u003estruct node* current = head;\u003cxhtml:br/\u003eint count = 0;\u003cxhtml:br/\u003ewhile (current != NULL) {\u003cxhtml:div style=\"margin-left:10px;\"\u003ecount++;\u003cxhtml:br/\u003ecurrent = current-\u0026gt;next;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003ereturn count;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    }
  ],
  "references": [
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CLASP",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01T00:00:00Z",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Other_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Taxonomy_Mappings, White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Improper Pointer Subtraction",
        "date": "2008-04-11T00:00:00Z"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Improper pointer subtraction"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Do not subtract or compare two pointers that do not refer to the same array",
      "entry_id": "ARR36-C",
      "mapping_fit": "Exact"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Glitch in Computation",
      "entry_id": "SFP1"
    }
  ]
}
