{
  "id": "843",
  "name": "Access of Resource Using Incompatible Type ('Type Confusion')",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The program allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
  "extended_description": "\n            \u003cxhtml:p\u003eWhen the program accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\u003c/xhtml:p\u003e\n         ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "704",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "704",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "CanPrecede",
      "cweid": "119",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Availability",
        "Integrity",
        "Confidentiality"
      ],
      "impact": [
        "Read Memory",
        "Modify Memory",
        "Execute Unauthorized Code or Commands",
        "DoS: Crash, Exit, or Restart"
      ],
      "note": "When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution."
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThe following code uses a union to support the representation of different types of messages. It formats messages differently, depending on their type.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e#define NAME_TYPE 1\u003cxhtml:br/\u003e#define ID_TYPE 2\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003estruct MessageBuffer\u003cxhtml:br/\u003e{\u003cxhtml:div style=\"margin-left:10px;\"\u003eint msgType;\u003cxhtml:br/\u003eunion {\u003cxhtml:div style=\"margin-left:10px;\"\u003echar *name;\u003cxhtml:br/\u003eint nameID;\u003c/xhtml:div\u003e};\u003c/xhtml:div\u003e};\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eint main (int argc, char **argv) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003estruct MessageBuffer buf;\u003cxhtml:br/\u003echar *defaultMessage = \"Hello World\";\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003ebuf.msgType = NAME_TYPE;\u003cxhtml:br/\u003ebuf.name = defaultMessage;\u003cxhtml:br/\u003eprintf(\"Pointer of buf.name is %p\\n\", buf.name);\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* This particular value for nameID is used to make the code architecture-independent. If coming from untrusted input, it could be any value. */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003ebuf.nameID = (int)(defaultMessage + 1);\u003cxhtml:br/\u003eprintf(\"Pointer of buf.name is now %p\\n\", buf.name);\u003cxhtml:br/\u003eif (buf.msgType == NAME_TYPE) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eprintf(\"Message: %s\\n\", buf.name);\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse {\u003cxhtml:div style=\"margin-left:10px;\"\u003eprintf(\"Message: Use ID %d\\n\", buf.nameID);\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe code intends to process the message as a NAME_TYPE, and sets the default message to \"Hello World.\" However, since both buf.name and buf.nameID are part of the same union, they can act as aliases for the same memory location, depending on memory layout after compilation.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eAs a result, modification of buf.nameID - an int - can effectively modify the pointer that is stored in buf.name - a string.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eExecution of the program might generate output such as:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003ePointer of name is 10830\u003c/xhtml:div\u003e\n                     \u003cxhtml:div\u003ePointer of name is now 10831\u003c/xhtml:div\u003e\n                     \u003cxhtml:div\u003eMessage: ello World\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003eNotice how the pointer for buf.name was changed, even though buf.name was not explicitly modified.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eIn this case, the first \"H\" character of the message is omitted. However, if an attacker is able to fully control the value of buf.nameID, then buf.name could contain an arbitrary pointer, leading to out-of-bounds reads or writes.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThe following PHP code accepts a value, adds 5, and prints the sum.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"PHP\"\u003e\n                  \u003cxhtml:div\u003e$value = $_GET['value'];\u003cxhtml:br/\u003e$sum = $value + 5;\u003cxhtml:br/\u003eecho \"value parameter is '$value'\u0026lt;p\u0026gt;\";\u003cxhtml:br/\u003eecho \"SUM is $sum\";\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eWhen called with the following query string:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003evalue=123\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003ethe program calculates the sum and prints out:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003eSUM is 128\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003eHowever, the attacker could supply a query string such as:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003evalue[]=123\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n               \u003cBody_Text\u003eThe \"[]\" array syntax causes $value to be treated as an array type, which then generates a fatal error when calculating $sum:\u003c/Body_Text\u003e\n               \u003cBody_Text\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:div\u003eFatal error: Unsupported operand types in program.php on line 2\u003c/xhtml:div\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThe following Perl code is intended to look up the privileges for user ID's between 0 and 3, by performing an access of the $UserPrivilegeArray reference. It is expected that only userID 3 is an admin (since this is listed in the third element of the array).\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Perl\"\u003e\n                  \u003cxhtml:div\u003emy $UserPrivilegeArray = [\"user\", \"user\", \"admin\", \"user\"];\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003emy $userID = get_current_user_ID();\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eif ($UserPrivilegeArray eq \"user\") {\u003cxhtml:div style=\"margin-left:10px;\"\u003eprint \"Regular user!\\n\";\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse {\u003cxhtml:div style=\"margin-left:10px;\"\u003eprint \"Admin!\\n\";\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eprint \"\\$UserPrivilegeArray = $UserPrivilegeArray\\n\";\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIn this case, the programmer intended to use \"$UserPrivilegeArray-\u0026gt;{$userID}\" to access the proper position in the array. But because the subscript was omitted, the \"user\" string was compared to the scalar representation of the $UserPrivilegeArray reference, which might be of the form \"ARRAY(0x229e8)\" or similar.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eSince the logic also \"fails open\" (CWE-636), the result of this bug is that all users are assigned administrator privileges.\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eWhile this is a forced example, it demonstrates how type confusion can have security consequences, even in memory-safe languages.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2010-4577",
      "description": "Type confusion in CSS sequence leads to out-of-bounds read.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4577"
    },
    {
      "reference": "CVE-2011-0611",
      "description": "Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0611"
    },
    {
      "reference": "CVE-2010-0258",
      "description": "Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0258"
    }
  ],
  "references": [
    {
      "section": "\"Type Confusion Vulnerabilities,\" page 59",
      "reference_id": "REF-811",
      "author": [
        "Mark Dowd",
        "Ryan Smith",
        "David Dewey"
      ],
      "title": "Attacking Interoperability",
      "url": "http://www.azimuthsecurity.com/resources/bh2009_dowd_smith_dewey.pdf",
      "publication_year": "2009"
    },
    {
      "section": "Chapter 7, \"Type Confusion\", Page 319",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2011-05-15T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Research_Gaps"
      }
    ]
  },
  "alternate_terms": [
    {
      "term": "Object Type Confusion"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Do not access a variable through a pointer of an incompatible type",
      "entry_id": "EXP39-C",
      "mapping_fit": "Exact"
    }
  ],
  "notes": [
    {
      "type": "Applicable Platform",
      "text": "\n               \u003cxhtml:p\u003eThis weakness is possible in any type-unsafe programming language.\u003c/xhtml:p\u003e\n            "
    },
    {
      "type": "Research Gap",
      "text": "\n               \u003cxhtml:p\u003eType confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.\u003c/xhtml:p\u003e\n               \u003cxhtml:p\u003eFor other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis.\u003c/xhtml:p\u003e\n            "
    }
  ]
}
