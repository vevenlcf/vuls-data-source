{
  "id": "135",
  "name": "Incorrect Calculation of Multi-Byte String Length",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software does not correctly calculate the length of strings that can contain wide or multi-byte characters.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation",
      "note": [
        "\n                  \u003cxhtml:p\u003eThere are several ways in which improper string length checking may result in an exploitable condition. All of these, however, involve the introduction of buffer overflow conditions in order to reach an exploitable state.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eThe first of these issues takes place when the output of a wide or multi-byte character string, string-length function is used as a size for the allocation of memory. While this will result in an output of the number of characters in the string, note that the characters are most likely not a single byte, as they are with standard character strings. So, using the size returned as the size sent to new or malloc and copying the string to this newly allocated memory will result in a buffer overflow.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eAnother common way these strings are misused involves the mixing of standard string and wide or multi-byte string functions on a single string. Invariably, this mismatched information will result in the creation of a possibly exploitable buffer overflow condition.\u003c/xhtml:p\u003e\n               "
      ]
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands"
      ],
      "note": "This weakness may lead to a buffer overflow. Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service."
    },
    {
      "scope": [
        "Availability",
        "Confidentiality"
      ],
      "impact": [
        "Read Memory",
        "DoS: Crash, Exit, or Restart",
        "DoS: Resource Consumption (CPU)",
        "DoS: Resource Consumption (Memory)"
      ],
      "note": "Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."
    },
    {
      "scope": [
        "Confidentiality"
      ],
      "impact": [
        "Read Memory"
      ],
      "note": "In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Always verify the length of the string unit character."
      ],
      "strategy": "Input Validation"
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Use length computing functions (e.g. strlen, wcslen, etc.) appropriately with their equivalent type (e.g.: byte, wchar_t, etc.)"
      ],
      "strategy": "Libraries or Frameworks"
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThe following example would be exploitable if any of the commented incorrect malloc calls were used.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e#include \u0026lt;stdio.h\u0026gt;\u003cxhtml:br/\u003e#include \u0026lt;strings.h\u0026gt;\u003cxhtml:br/\u003e#include \u0026lt;wchar.h\u0026gt;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eint main() {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e\n                           \u003cxhtml:br/\u003ewchar_t wideString[] = L\"The spazzy orange tiger jumped \" \\\u003cxhtml:br/\u003e\"over the tawny jaguar.\";\u003cxhtml:br/\u003ewchar_t *newString;\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003eprintf(\"Strlen() output: %d\\nWcslen() output: %d\\n\",\u003cxhtml:br/\u003estrlen(wideString), wcslen(wideString));\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e/* Wrong because the number of chars in a string isn't related to its length in bytes //\u003cxhtml:br/\u003enewString = (wchar_t *) malloc(strlen(wideString));\u003cxhtml:br/\u003e*/\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e/* Wrong because wide characters aren't 1 byte long! //\u003cxhtml:br/\u003enewString = (wchar_t *) malloc(wcslen(wideString));\u003cxhtml:br/\u003e*/\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e/* Wrong because wcslen does not include the terminating null */\u003cxhtml:br/\u003enewString = (wchar_t *) malloc(wcslen(wideString) * sizeof(wchar_t));\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e/* correct! */\u003cxhtml:br/\u003enewString = (wchar_t *) malloc((wcslen(wideString) + 1) * sizeof(wchar_t));\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e/* ... */\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe output from the printf() statement would be:\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"result\"\u003e\n                  \u003cxhtml:div\u003eStrlen() output: 0\u003cxhtml:br/\u003eWcslen() output: 53\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    }
  ],
  "references": [
    {
      "section": "Chapter 5, \"Unicode and ANSI Buffer Size Mismatches\" Page 153",
      "reference_id": "REF-7",
      "author": [
        "Michael Howard",
        "David LeBlanc"
      ],
      "title": "Writing Secure Code",
      "url": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223",
      "publication_year": "2002",
      "publication_month": "--12",
      "publication_day": "---04",
      "publisher": "Microsoft Press",
      "edition": "2nd Edition"
    },
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CLASP",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Time_of_Introduction"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Relationships, Other_Notes, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Enabling_Factors_for_Exploitation, Other_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Enabling_Factors_for_Exploitation, Modes_of_Introduction, References, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated References"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Improper String Length Checking",
        "date": "2008-04-11T00:00:00Z"
      }
    ],
    "contribution": [
      {
        "type": "Feedback",
        "contribution_name": "Gregory Padgett",
        "contribution_organization": "Unitrends",
        "contribution_date": "2010-01-11T00:00:00Z",
        "contribution_comment": "correction to Demonstrative_Example"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Improper string length checking"
    },
    {
      "taxonomy_name": "The CERT Oracle Secure Coding Standard for Java (2011)",
      "entry_name": "Ensure the array is filled when using read() to fill an array",
      "entry_id": "FIO10-J"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Incorrect Buffer Length Computation",
      "entry_id": "SFP10"
    }
  ]
}
