{
  "id": "762",
  "name": "Mismatched Memory Management Routines",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The application attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.",
  "extended_description": "\n            \u003cxhtml:p\u003eThis weakness can be generally described as mismatching memory management routines, such as:\u003c/xhtml:p\u003e\n            \u003cxhtml:div style=\"margin-left:10px;\"\u003e\n               \u003cxhtml:ul\u003e\n                  \u003cxhtml:li\u003eThe memory was allocated on the stack (automatically), but it was deallocated using the memory management routine free() (CWE-590), which is intended for explicitly allocated heap memory.\u003c/xhtml:li\u003e\n                  \u003cxhtml:li\u003eThe memory was allocated explicitly using one set of memory management functions, and deallocated using a different set. For example, memory might be allocated with malloc() in C++ instead of the new operator, and then deallocated with the delete operator.\u003c/xhtml:li\u003e\n               \u003c/xhtml:ul\u003e\n            \u003c/xhtml:div\u003e\n            \u003cxhtml:p\u003eWhen the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.\u003c/xhtml:p\u003e\n         ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "763",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "404",
      "view_id": "1340",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "Low",
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Availability",
        "Confidentiality"
      ],
      "impact": [
        "Modify Memory",
        "DoS: Crash, Exit, or Restart",
        "Execute Unauthorized Code or Commands"
      ]
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free()."
      ]
    },
    {
      "mitigation_id": "MIT-41",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eChoose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eFor example, glibc in Linux provides protection against free of invalid pointers.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eWhen using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eTo help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.\u003c/xhtml:p\u003e\n               "
      ],
      "strategy": "Libraries or Frameworks"
    },
    {
      "mitigation_id": "MIT-4.6",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "\n                  \u003cxhtml:p\u003eUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003eFor example, glibc in Linux provides protection against free of invalid pointers.\u003c/xhtml:p\u003e\n               "
      ],
      "strategy": "Libraries or Frameworks"
    },
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Use a language that provides abstractions for memory allocation and deallocation."
      ]
    },
    {
      "phase": [
        "Testing"
      ],
      "description": [
        "Use a tool that dynamically detects memory management problems, such as valgrind."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-80",
      "text": "\n               \u003cIntro_Text\u003eThis example allocates a BarObj object using the new operator in C++, however, the programmer then deallocates the object using free(), which may lead to unexpected behavior.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C++\"\u003e\n                  \u003cxhtml:div\u003evoid foo(){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eBarObj *ptr = new BarObj()\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* do some work with ptr here */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003efree(ptr);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eInstead, the programmer should have either created the object with one of the malloc family functions, or else deleted the object with the delete operator.\u003c/Body_Text\u003e\n               \u003cExample_Code Nature=\"good\" Language=\"C++\"\u003e\n                  \u003cxhtml:div\u003evoid foo(){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003eBarObj *ptr = new BarObj()\u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* do some work with ptr here */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e...\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003edelete ptr;\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-85",
      "text": "\n               \u003cIntro_Text\u003eIn this example, the program does not use matching functions such as malloc/free, new/delete, and new[]/delete[] to allocate/deallocate the resource.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C++\"\u003e\n                  \u003cxhtml:div\u003eclass A {\u003cxhtml:div style=\"margin-left:10px;\"\u003evoid foo();\u003c/xhtml:div\u003e};\u003cxhtml:br/\u003evoid A::foo(){\u003cxhtml:div style=\"margin-left:10px;\"\u003eint *ptr;\u003cxhtml:br/\u003eptr = (int*)malloc(sizeof(int));\u003cxhtml:br/\u003edelete ptr;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-86",
      "text": "\n               \u003cIntro_Text\u003eIn this example, the program calls the delete[] function on non-heap memory.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C++\"\u003e\n                  \u003cxhtml:div\u003eclass A{\u003cxhtml:div style=\"margin-left:10px;\"\u003evoid foo(bool);\u003c/xhtml:div\u003e};\u003cxhtml:br/\u003evoid A::foo(bool heap) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eint localArray[2] = {\u003cxhtml:div style=\"margin-left:10px;\"\u003e11,22\u003c/xhtml:div\u003e};\u003cxhtml:br/\u003eint *p = localArray;\u003cxhtml:br/\u003eif (heap){\u003cxhtml:div style=\"margin-left:10px;\"\u003ep = new int[2];\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003edelete[] p;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    }
  ],
  "references": [
    {
      "reference_id": "REF-657",
      "title": "boost C++ Library Smart Pointers",
      "url": "http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/smart_ptr.htm"
    },
    {
      "reference_id": "REF-480",
      "title": "Valgrind",
      "url": "http://valgrind.org/"
    },
    {
      "reference_id": "REF-391",
      "author": [
        "iOS Developer Library"
      ],
      "title": "Transitioning to ARC Release Notes",
      "url": "https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html",
      "publication_year": "2013",
      "publication_month": "--08",
      "publication_day": "---08"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CWE Content Team",
      "submission_organization": "MITRE",
      "submission_date": "2009-05-08T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-12-28T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Likelihood_of_Exploit"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-06-21T00:00:00Z",
        "modification_comment": "updated Description, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, References, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Relationships"
      }
    ],
    "contribution": [
      {
        "type": "Feedback",
        "contribution_name": "Martin Sebor",
        "contribution_organization": "Cisco Systems, Inc.",
        "contribution_date": "2010-04-30T00:00:00Z",
        "contribution_comment": "Provided improvement to existing Mitigation"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Properly pair allocation and deallocation functions",
      "entry_id": "WIN30-C",
      "mapping_fit": "Exact"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Memory Release",
      "entry_id": "SFP12"
    }
  ],
  "notes": [
    {
      "type": "Applicable Platform",
      "text": "\n               \u003cxhtml:p\u003eThis weakness is possible in any programming language that allows manual management of memory.\u003c/xhtml:p\u003e\n            "
    }
  ],
  "affected_resources": [
    "Memory"
  ]
}
