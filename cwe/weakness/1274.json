{
  "id": "1274",
  "name": "Improper Access Control for Volatile Memory Containing Boot Code",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Stable",
  "description": "The product conducts a secure-boot process that transfers bootloader code from Non-Volatile Memory (NVM) into Volatile Memory (VM), but it does not have sufficient access control or other protections for the Volatile Memory.",
  "extended_description": "\n\t\t\t  \u003cxhtml:p\u003eAdversaries could bypass the secure-boot process and execute their own untrusted, malicious boot code.\u003c/xhtml:p\u003e\n\t\t\t  \u003cxhtml:p\u003eAs a part of a secure-boot process, the read-only-memory (ROM) code for a System-on-Chip (SoC) or other system fetches bootloader code from Non-Volatile Memory (NVM) and stores the code in Volatile Memory (VM), such as dynamic, random-access memory (DRAM) or static, random-access memory (SRAM). The NVM is usually external to the SoC, while the VM is internal to the SoC. As the code is transferred from NVM to VM, it is authenticated by the SoC's ROM code.\u003c/xhtml:p\u003e\n\t\t\t  \u003cxhtml:p\u003eIf the volatile-memory-region protections or access controls are insufficient to prevent modifications from an adversary or untrusted agent, the secure boot may be bypassed or replaced with the execution of an adversary's code.\u003c/xhtml:p\u003e\n\t\t\t",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "284",
      "view_id": "1000",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "class": "Language-Independent",
        "prevalence": "Undetermined"
      }
    ],
    "technology": [
      {
        "class": "Technology-Independent",
        "prevalence": "Undetermined"
      }
    ],
    "operating_system": [
      {
        "class": "OS-Independent",
        "prevalence": "Undetermined"
      }
    ],
    "architecture": [
      {
        "class": "Architecture-Independent",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Architecture and Design",
      "note": [
        "This weakness can be introduced during hardware architecture or design but can be identified later during testing."
      ]
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Access Control",
        "Integrity"
      ],
      "impact": [
        "Modify Memory",
        "Execute Unauthorized Code or Commands",
        "Gain Privileges or Assume Identity"
      ],
      "likelihood": "High"
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Ensure that the design of volatile-memory protections is enough to prevent modification from an adversary or untrusted code."
      ]
    },
    {
      "phase": [
        "Testing"
      ],
      "description": [
        "Test the volatile-memory protections to ensure they are safe from modification or untrusted code."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n\t\t\t\t\t\u003cIntro_Text\u003eA typical SoC secure boot's flow includes fetching the next piece of code (i.e., the boot loader) from NVM (e.g., serial, peripheral interface (SPI) flash), and transferring it to DRAM/SRAM volatile, internal memory, which is more efficient.\u003c/Intro_Text\u003e\n\t\t\t\t\t\u003cExample_Code Nature=\"bad\"\u003eThe volatile-memory protections or access controls are insufficient.\u003c/Example_Code\u003e\n\t\t\t\t\t\u003cBody_Text\u003eThe memory from where the boot loader executes can be modified by an adversary.\u003c/Body_Text\u003e\n\t\t\t\t\t\u003cExample_Code Nature=\"good\"\u003eA good architecture should define appropriate protections or access controls to prevent modification by an adversary or untrusted agent, once the bootloader is authenticated.\u003c/Example_Code\u003e\n\t\t\t\t"
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2019-2267",
      "description": "Locked memory regions may be modified through other interfaces in a secure-boot-loader image due to improper access control.",
      "link": "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2267"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi",
      "submission_organization": "Intel Corporation",
      "submission_date": "2020-04-25T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Description, Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-10-28T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, Relationships, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Insufficient Protections on the Volatile Memory Containing Boot Code",
        "date": "2021-10-28T00:00:00Z"
      }
    ],
    "contribution": [
      {
        "type": "Feedback",
        "contribution_name": "Narasimha Kumar V Mangipudi",
        "contribution_organization": "Lattice Semiconductor",
        "contribution_date": "2021-10-20T00:00:00Z",
        "contribution_comment": "suggested content improvements"
      },
      {
        "type": "Content",
        "contribution_name": "Hareesh Khattri",
        "contribution_organization": "Intel Corporation",
        "contribution_date": "2021-10-22T00:00:00Z",
        "contribution_comment": "provided detection method"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Primary"
    }
  ],
  "detection_methods": [
    {
      "method": "Manual Analysis",
      "description": "Ensure the volatile memory is lockable or has locks. Ensure the volatile memory is locked for writes from untrusted agents or adversaries. Try modifying the volatile memory from an untrusted agent, and ensure these writes are dropped.\n\t\t\t     ",
      "effectiveness": "High"
    },
    {
      "method": "Manual Analysis",
      "description": "\n\t\t\t      \u003cxhtml:p\u003eAnalyze the device using the following steps:\u003c/xhtml:p\u003e\n\t\t\t      \u003cxhtml:ul\u003e\n\t\t\t\t\u003cxhtml:li\u003e1) Identify all fabric master agents that are active during system Boot Flow when initial code is loaded from Non-volatile storage to volatile memory.\u003c/xhtml:li\u003e\n\t\t\t\t\u003cxhtml:li\u003e2) Identify the volatile memory regions that are used for storing loaded system executable program.\u003c/xhtml:li\u003e\n\t\t\t\t\u003cxhtml:li\u003e3) During system boot, test programming the identified memory regions in step 2 from all the masters identified in step 1.\u003c/xhtml:li\u003e\n\t\t\t      \u003c/xhtml:ul\u003e\n\t\t\t      \u003cxhtml:p\u003eOnly trusted masters should be allowed to write to the memory regions. For example, pluggable device peripherals should not have write access to program load memory regions.\u003c/xhtml:p\u003e\n\t\t\t    ",
      "effectiveness": "Moderate"
    }
  ],
  "related_attack_patterns": [
    "679"
  ]
}
