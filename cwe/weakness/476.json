{
  "id": "476",
  "name": "NULL Pointer Dereference",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Stable",
  "description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
  "extended_description": "NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "710",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "754",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "754",
      "view_id": "1003",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "prevalence": "Undetermined",
        "name": "Java"
      },
      {
        "prevalence": "Undetermined",
        "name": "C#"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "Medium",
  "common_consequences": [
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart"
      ],
      "note": "NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation."
    },
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands",
        "Read Memory",
        "Modify Memory"
      ],
      "note": "In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution."
    }
  ],
  "potential_mitigations": [
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "If all pointers that could have been modified are sanity-checked previous to use, nearly all NULL pointer dereferences can be prevented."
      ]
    },
    {
      "phase": [
        "Requirements"
      ],
      "description": [
        "The choice could be made to use a language that is not susceptible to these issues."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Check the results of all functions that return a value and verify that the value is non-null before acting upon it."
      ],
      "effectiveness": "Moderate",
      "effectiveness_notes": "Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665)."
    },
    {
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."
      ]
    },
    {
      "phase": [
        "Implementation"
      ],
      "description": [
        "Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage."
      ]
    },
    {
      "phase": [
        "Testing"
      ],
      "description": [
        "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
      ]
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eWhile there are no complete fixes aside from conscientious programming, the following steps will go a long way to ensure that NULL pointer dereferences do not occur.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"good\"\u003e\n                  \u003cxhtml:div\u003eif (pointer1 != NULL) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* make use of pointer1 */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* ... */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                        \u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf you are working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the if statement; and unlock when it has finished.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-1",
      "text": "\n               \u003cIntro_Text\u003eThis example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003evoid host_lookup(char *user_supplied_addr){\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003estruct hostent *hp;\u003cxhtml:br/\u003ein_addr_t *addr;\u003cxhtml:br/\u003echar hostname[64];\u003cxhtml:br/\u003ein_addr_t inet_addr(const char *cp);\u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/*routine that ensures user_supplied_addr is in the right format for conversion */\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003evalidate_addr_form(user_supplied_addr);\u003cxhtml:br/\u003eaddr = inet_addr(user_supplied_addr);\u003cxhtml:br/\u003ehp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\u003cxhtml:br/\u003estrcpy(hostname, hp-\u0026gt;h_name);\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to gethostbyaddr() will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to strcpy().\u003c/Body_Text\u003e\n               \u003cBody_Text\u003eNote that this code is also vulnerable to a buffer overflow (CWE-119).\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eIn the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a NULL pointer exception when it attempts to call the trim() method.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003eString cmd = System.getProperty(\"cmd\");\u003cxhtml:br/\u003ecmd = cmd.trim();\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-110",
      "text": "\n               \u003cIntro_Text\u003eThis Android application has registered to handle a URL when sent an intent:\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"Java\"\u003e\n                  \u003cxhtml:div\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e...\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003eIntentFilter filter = new IntentFilter(\"com.example.URLHandler.openURL\");\u003cxhtml:br/\u003eMyReceiver receiver = new MyReceiver();\u003cxhtml:br/\u003eregisterReceiver(receiver, filter);\u003cxhtml:br/\u003e\n                     \u003cxhtml:i\u003e...\u003c/xhtml:i\u003e\n                     \u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003epublic class UrlHandlerReceiver extends BroadcastReceiver {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e@Override\u003cxhtml:br/\u003epublic void onReceive(Context context, Intent intent) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                              \u003cxhtml:div\u003eif(\"com.example.URLHandler.openURL\".equals(intent.getAction())) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eString URL = intent.getStringExtra(\"URLToOpen\");\u003cxhtml:br/\u003eint length = URL.length();\u003c/xhtml:div\u003e\n                                 \u003cxhtml:br/\u003e\n                                 \u003cxhtml:i\u003e...\u003c/xhtml:i\u003e\n                                 \u003cxhtml:br/\u003e}\u003c/xhtml:div\u003e\n                           \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe application assumes the URL will always be included in the intent. When the URL is not present, the call to getStringExtra() will return null, thus causing a null pointer exception when length() is called.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2005-3274",
      "description": "race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3274"
    },
    {
      "reference": "CVE-2002-1912",
      "description": "large number of packets leads to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-1912"
    },
    {
      "reference": "CVE-2005-0772",
      "description": "packet with invalid error status value triggers NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0772"
    },
    {
      "reference": "CVE-2009-4895",
      "description": "Chain: race condition for an argument value, possibly resulting in NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4895"
    },
    {
      "reference": "CVE-2009-2692",
      "description": "Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2692"
    },
    {
      "reference": "CVE-2009-3547",
      "description": "Chain: race condition might allow resource to be released before operating on it, leading to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3547"
    },
    {
      "reference": "CVE-2009-3620",
      "description": "Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3620"
    },
    {
      "reference": "CVE-2009-2698",
      "description": "Chain: IP and UDP layers each track the same value with different mechanisms that can get out of sync, possibly resulting in a NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2698"
    },
    {
      "reference": "CVE-2009-2692",
      "description": "Chain: uninitialized function pointers can be dereferenced allowing code execution",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2692"
    },
    {
      "reference": "CVE-2009-0949",
      "description": "Chain: improper initialization of memory can lead to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0949"
    },
    {
      "reference": "CVE-2008-3597",
      "description": "Chain: game server can access player data structures before initialization has happened leading to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3597"
    },
    {
      "reference": "CVE-2020-6078",
      "description": "Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-6078"
    },
    {
      "reference": "CVE-2008-0062",
      "description": "Chain: a message having an unknown message type may cause a reference to uninitialized memory resulting in a null pointer dereference (CWE-476) or dangling pointer (CWE-825), possibly crashing the system or causing heap corruption.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0062"
    },
    {
      "reference": "CVE-2008-5183",
      "description": "Chain: unchecked return value can lead to NULL dereference",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5183"
    },
    {
      "reference": "CVE-2004-0079",
      "description": "SSL software allows remote attackers to cause a denial of service (crash) via a crafted SSL/TLS handshake that triggers a null dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0079"
    },
    {
      "reference": "CVE-2004-0365",
      "description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed RADIUS packet that triggers a null dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0365"
    },
    {
      "reference": "CVE-2003-1013",
      "description": "Network monitor allows remote attackers to cause a denial of service (crash) via a malformed Q.931, which triggers a null dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1013"
    },
    {
      "reference": "CVE-2003-1000",
      "description": "Chat client allows remote attackers to cause a denial of service (crash) via a passive DCC request with an invalid ID number, which causes a null dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1000"
    },
    {
      "reference": "CVE-2004-0389",
      "description": "Server allows remote attackers to cause a denial of service (crash) via malformed requests that trigger a null dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0389"
    },
    {
      "reference": "CVE-2004-0119",
      "description": "OS allows remote attackers to cause a denial of service (crash from null dereference) or execute arbitrary code via a crafted request during authentication protocol selection.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0119"
    },
    {
      "reference": "CVE-2004-0458",
      "description": "Game allows remote attackers to cause a denial of service (server crash) via a missing argument, which triggers a null pointer dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0458"
    },
    {
      "reference": "CVE-2002-0401",
      "description": "Network monitor allows remote attackers to cause a denial of service (crash) or execute arbitrary code via malformed packets that cause a NULL pointer dereference.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0401"
    }
  ],
  "references": [
    {
      "reference_id": "REF-6",
      "author": [
        "Katrina Tsipenyuk",
        "Brian Chess",
        "Gary McGraw"
      ],
      "title": "Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors",
      "url": "https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf",
      "publication_year": "2005",
      "publication_month": "--11",
      "publication_day": "---07",
      "publication": "NIST Workshop on Software Security Assurance Tools Techniques and Metrics",
      "publisher": "NIST"
    },
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    },
    {
      "reference_id": "REF-1031",
      "title": "Null pointer / Null dereferencing",
      "url": "https://en.wikipedia.org/wiki/Null_pointer#Null_dereferencing",
      "publication_year": "2019",
      "publication_month": "--07",
      "publication_day": "---15",
      "publisher": "Wikipedia"
    },
    {
      "reference_id": "REF-1032",
      "title": "Null Reference Creation and Null Pointer Dereference",
      "url": "https://developer.apple.com/documentation/code_diagnostics/undefined_behavior_sanitizer/null_reference_creation_and_null_pointer_dereference",
      "publisher": "Apple"
    },
    {
      "reference_id": "REF-1033",
      "title": "NULL Pointer Dereference [CWE-476]",
      "url": "https://www.immuniweb.com/vulnerability/null-pointer-dereference.html",
      "publication_year": "2012",
      "publication_month": "--09",
      "publication_day": "---11",
      "publisher": "ImmuniWeb"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "7 Pernicious Kingdoms",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01T00:00:00Z",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-12-28T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Demonstrative_Examples, Other_Notes, Potential_Mitigations, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Potential_Mitigations, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-06-21T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Description, Detection_Factors, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Observed_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-12-13T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Related_Attack_Patterns, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Observed_Examples, Related_Attack_Patterns, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2015-12-07T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-01-19T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings, White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-09-19T00:00:00Z",
        "modification_comment": "updated References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Observed_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-07-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Alternate_Terms"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-06-28T00:00:00Z",
        "modification_comment": "updated Relationships"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Resultant",
      "description": "NULL pointer dereferences are frequently resultant from rarely encountered error conditions, since these are most likely to escape detection during the testing phases."
    }
  ],
  "alternate_terms": [
    {
      "term": "NPD"
    },
    {
      "term": "null deref"
    }
  ],
  "detection_methods": [
    {
      "detection_method_id": "DM-2",
      "method": "Automated Dynamic Analysis",
      "description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
      "effectiveness": "Moderate"
    },
    {
      "detection_method_id": "DM-12",
      "method": "Manual Dynamic Analysis",
      "description": "Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "7 Pernicious Kingdoms",
      "entry_name": "Null Dereference"
    },
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Null-pointer dereference"
    },
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Null Dereference (Null Pointer Dereference)"
    },
    {
      "taxonomy_name": "OWASP Top Ten 2004",
      "entry_name": "Denial of Service",
      "entry_id": "A9",
      "mapping_fit": "CWE More Specific"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Do not dereference null pointers",
      "entry_id": "EXP34-C",
      "mapping_fit": "Exact"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Pointer Use",
      "entry_id": "SFP7"
    }
  ]
}
