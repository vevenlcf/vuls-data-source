{
  "id": "191",
  "name": "Integer Underflow (Wrap or Wraparound)",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Draft",
  "description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
  "extended_description": "This can happen in signed and unsigned cases.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "682",
      "view_id": "1003",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "prevalence": "Undetermined",
        "name": "Java"
      },
      {
        "prevalence": "Undetermined",
        "name": "C#"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "DoS: Crash, Exit, or Restart",
        "DoS: Resource Consumption (CPU)",
        "DoS: Resource Consumption (Memory)",
        "DoS: Instability"
      ],
      "note": "This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high."
    },
    {
      "scope": [
        "Integrity"
      ],
      "impact": [
        "Modify Memory"
      ],
      "note": "If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur."
    },
    {
      "scope": [
        "Confidentiality",
        "Availability",
        "Access Control"
      ],
      "impact": [
        "Execute Unauthorized Code or Commands",
        "Bypass Protection Mechanism"
      ],
      "note": "This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy."
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               \u003cIntro_Text\u003eThe following example subtracts from a 32 bit signed integer.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e#include \u0026lt;stdio.h\u0026gt;\u003cxhtml:br/\u003e#include \u0026lt;stdbool.h\u0026gt;\u003cxhtml:br/\u003emain (void)\u003cxhtml:br/\u003e{\u003cxhtml:div style=\"margin-left:10px;\"\u003eint i;\u003cxhtml:br/\u003ei = -2147483648;\u003cxhtml:br/\u003ei = i - 1;\u003cxhtml:br/\u003ereturn 0;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003e\n                  \u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe example has an integer underflow. The value of i is already at the lowest negative value possible, so after subtracting 1, the new value of i is 2147483647.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-137",
      "text": "\n               \u003cIntro_Text\u003eThis code performs a stack allocation based on a length calculation.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003e\n\t\t    int a = 5, b = 6;\u003cxhtml:br/\u003e\n\t\t    size_t len = a - b;\u003cxhtml:br/\u003e\n\t\t    char buf[len];    // Just blows up the stack\n\t\t  \u003c/xhtml:div\u003e\n\t\t  }\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eSince a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space.\u003c/Body_Text\u003e\n\t       \u003cBody_Text\u003eMiscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2004-0816",
      "description": "Integer underflow in firewall via malformed packet.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0816"
    },
    {
      "reference": "CVE-2004-1002",
      "description": "Integer underflow by packet with invalid length.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1002"
    },
    {
      "reference": "CVE-2005-0199",
      "description": "Long input causes incorrect length calculation.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0199"
    },
    {
      "reference": "CVE-2005-1891",
      "description": "Malformed icon causes integer underflow in loop counter variable.",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1891"
    }
  ],
  "references": [
    {
      "section": "\"Sin 7: Integer Overflows.\" Page 119",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01T00:00:00Z",
        "modification_comment": "updated Demonstrative_Example"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Alternate_Terms, Applicable_Platforms, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-14T00:00:00Z",
        "modification_comment": "updated Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Common_Consequences, References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2015-12-07T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-04-28T00:00:00Z",
        "modification_comment": "updated Research_Gaps"
      }
    ]
  },
  "alternate_terms": [
    {
      "term": "Integer underflow",
      "description": "\n                  \u003cxhtml:p\u003e\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\u003c/xhtml:p\u003e\n                  \u003cxhtml:p\u003e\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\u003c/xhtml:p\u003e\n               "
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Integer underflow (wrap or wraparound)"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Glitch in computation",
      "entry_id": "SFP1"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Ensure that unsigned integer operations do not wrap",
      "entry_id": "INT30-C",
      "mapping_fit": "Imprecise"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Ensure that operations on signed integers do not result in overflow",
      "entry_id": "INT32-C",
      "mapping_fit": "Imprecise"
    }
  ]
}
