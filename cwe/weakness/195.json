{
  "id": "195",
  "name": "Signed to Unsigned Conversion Error",
  "abstraction": "Variant",
  "structure": "Simple",
  "status": "Draft",
  "description": "The software uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.",
  "extended_description": "\n            \u003cxhtml:p\u003eIt is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.\u003c/xhtml:p\u003e\n            \u003cxhtml:p\u003eOften, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition.\u003c/xhtml:p\u003e\n         ",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "681",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "681",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "681",
      "view_id": "1340",
      "ordinal": "Primary"
    },
    {
      "nature": "CanPrecede",
      "cweid": "119",
      "view_id": "1000"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "common_consequences": [
    {
      "scope": [
        "Integrity"
      ],
      "impact": [
        "Unexpected State"
      ],
      "note": "Conversion between signed and unsigned values can lead to a variety of errors, but from a security standpoint is most commonly associated with integer overflow and buffer overflow vulnerabilities."
    }
  ],
  "demonstrative_examples": [
    {
      "demonstrative_example_id": "DX-73",
      "text": "\n               \u003cIntro_Text\u003eIn this example the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned int, amount will be implicitly converted to unsigned.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eunsigned int readdata () {\u003cxhtml:div style=\"margin-left:10px;\"\u003eint amount = 0;\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003eif (result == ERROR)\u003cxhtml:br/\u003eamount = -1;\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003ereturn amount;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf the error condition in the code above is met, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-74",
      "text": "\n               \u003cIntro_Text\u003eIn this example, depending on the return value of accecssmainframe(), the variable amount can hold a negative value when it is returned. Because the function is declared to return an unsigned value, amount will be implicitly cast to an unsigned number.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eunsigned int readdata () {\u003cxhtml:div style=\"margin-left:10px;\"\u003eint amount = 0;\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003eamount = accessmainframe();\u003cxhtml:br/\u003e...\u003cxhtml:br/\u003ereturn amount;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf the return value of accessmainframe() is -1, then the return value of readdata() will be 4,294,967,295 on a system that uses 32-bit integers.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-21",
      "text": "\n               \u003cIntro_Text\u003eThe following code is intended to read an incoming packet from a socket and extract one or more headers.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eDataPacket *packet;\u003cxhtml:br/\u003eint numHeaders;\u003cxhtml:br/\u003ePacketHeader *headers;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003esock=AcceptSocketConnection();\u003cxhtml:br/\u003eReadPacket(packet, sock);\u003cxhtml:br/\u003enumHeaders =packet-\u0026gt;headers;\u003cxhtml:br/\u003e\n                     \u003cxhtml:br/\u003eif (numHeaders \u0026gt; 100) {\u003cxhtml:div style=\"margin-left:10px;\"\u003eExitError(\"too many headers!\");\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eheaders = malloc(numHeaders * sizeof(PacketHeader);\u003cxhtml:br/\u003eParsePacketHeaders(packet, headers);\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow.\u003c/Body_Text\u003e\n            "
    },
    {
      "text": "\n               \u003cIntro_Text\u003eThis example processes user input comprised of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003echar* processNext(char* strm) {\u003cxhtml:div style=\"margin-left:10px;\"\u003echar buf[512];\u003cxhtml:br/\u003eshort len = *(short*) strm;\u003cxhtml:br/\u003estrm += sizeof(len);\u003cxhtml:br/\u003eif (len \u0026lt;= 512) {\u003cxhtml:div style=\"margin-left:10px;\"\u003ememcpy(buf, strm, len);\u003cxhtml:br/\u003eprocess(buf);\u003cxhtml:br/\u003ereturn strm + len;\u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eelse {\u003cxhtml:div style=\"margin-left:10px;\"\u003ereturn -1;\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe programmer has set an upper bound on the structure size: if it is larger than 512, the input will not be processed. The problem is that len is a signed short, so the check against the maximum structure length is done with signed values, but len is converted to an unsigned integer for the call to memcpy() and the negative bit will be extended to result in a huge value for the unsigned integer. If len is negative, then it will appear that the structure has an appropriate size (the if branch will be taken), but the amount of memory copied by memcpy() will be quite large, and the attacker will be able to overflow the stack with data in strm.\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-114",
      "text": "\n               \u003cIntro_Text\u003eIn the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n                  \u003cxhtml:div\u003eint returnChunkSize(void *) {\u003cxhtml:div style=\"margin-left:10px;\"\u003e\n                        \u003cxhtml:div\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e/* if chunk info is valid, return the size of usable memory,\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e* else, return -1 to indicate an error\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:br/\u003e\n                           \u003cxhtml:i\u003e*/\u003c/xhtml:i\u003e\n                           \u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e\n                     \u003c/xhtml:div\u003e}\u003cxhtml:br/\u003eint main() {\u003cxhtml:div style=\"margin-left:10px;\"\u003e...\u003cxhtml:br/\u003ememcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\u003cxhtml:br/\u003e...\u003c/xhtml:div\u003e}\u003c/xhtml:div\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eIf returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788).\u003c/Body_Text\u003e\n            "
    },
    {
      "demonstrative_example_id": "DX-138",
      "text": "\n               \u003cIntro_Text\u003eThis example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action.\u003c/Intro_Text\u003e\n               \u003cExample_Code Nature=\"bad\" Language=\"C\"\u003e\n\t\t int proc_msg(char *s, int msg_len)\u003cxhtml:br/\u003e\n\t\t {\u003cxhtml:br/\u003e\n                  \u003cxhtml:div\u003e\n\t\t    \u003cxhtml:i\u003e// Note space at the end of the string - assume all strings have preamble with space\u003c/xhtml:i\u003e\u003cxhtml:br/\u003e\n\t\t    int pre_len = sizeof(\"preamble: \");\u003cxhtml:br/\u003e\n\t\t    char buf[pre_len - msg_len];\u003cxhtml:br/\u003e\n\t\t    \u003cxhtml:i\u003e... Do processing here if we get this far\u003c/xhtml:i\u003e\n\t\t  \u003c/xhtml:div\u003e\n\t\t  }\u003cxhtml:br/\u003e\n\t\t  char *s = \"preamble: message\\n\";\u003cxhtml:br/\u003e\n\t\t  char *sl = strchr(s, ':');        // Number of characters up to ':' (not including space)\u003cxhtml:br/\u003e\n\t\t  int jnklen = sl == NULL ? 0 : sl - s;    // If undefined pointer, use zero length\u003cxhtml:br/\u003e\n\t\t  int ret_val = proc_msg (\"s\",  jnklen);    // Violate assumption of preamble length, end up with negative value, blow out stack\u003cxhtml:br/\u003e\n               \u003c/Example_Code\u003e\n               \u003cBody_Text\u003eThe buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations.\u003c/Body_Text\u003e\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2007-4268",
      "description": "Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)",
      "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4268"
    }
  ],
  "references": [
    {
      "section": "Chapter 6, \"Type Conversions\", Page 223",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "reference_id": "REF-18",
      "author": [
        "Secure Software, Inc."
      ],
      "title": "The CLASP Application Security Process",
      "url": "https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf",
      "publication_year": "2005"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "CLASP",
      "submission_date": "2006-07-19T00:00:00Z"
    },
    "modification": [
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08T00:00:00Z",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-05-27T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29T00:00:00Z",
        "modification_comment": "updated Common_Consequences, Description, Other_Notes, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-04-05T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27T00:00:00Z",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-06-23T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30T00:00:00Z",
        "modification_comment": "updated Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-01-19T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08T00:00:00Z",
        "modification_comment": "updated Observed_Examples, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10T00:00:00Z",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15T00:00:00Z",
        "modification_comment": "updated Demonstrative_Examples, References"
      }
    ]
  },
  "taxonomy_mappings": [
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Signed to unsigned conversion error"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Glitch in computation",
      "entry_id": "SFP1"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Ensure that integer conversions do not result in lost or misinterpreted data",
      "entry_id": "INT31-C",
      "mapping_fit": "CWE More Specific"
    }
  ]
}
