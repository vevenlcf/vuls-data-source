{
  "vid": "6aa2d135-b40e-11e5-9728-002590263bf5",
  "topic": "xen-kernel -- ioreq handling possibly susceptible to multiple read issue",
  "description": "\n\t\u003cp\u003eThe Xen Project reports:\u003c/p\u003e\n\t\u003cblockquote cite=\"http://xenbits.xen.org/xsa/advisory-166.html\"\u003e\n\t  \u003cp\u003eSingle memory accesses in source code can be translated to multiple\n\t    ones in machine code by the compiler, requiring special caution when\n\t    accessing shared memory.  Such precaution was missing from the\n\t    hypervisor code inspecting the state of I/O requests sent to the\n\t    device model for assistance.\u003c/p\u003e\n\t  \u003cp\u003eDue to the offending field being a bitfield, it is however believed\n\t    that there is no issue in practice, since compilers, at least when\n\t    optimizing (which is always the case for non-debug builds), should find\n\t    it more expensive to extract the bit field value twice than to keep the\n\t    calculated value in a register.\u003c/p\u003e\n\t  \u003cp\u003eThis vulnerability is exposed to malicious device models.  In\n\t    conventional Xen systems this means the qemu which service an HVM\n\t    domain.  On such systems this vulnerability can only be exploited if\n\t    the attacker has gained control of the device model qemu via another\n\t    vulnerability.\u003c/p\u003e\n\t  \u003cp\u003ePrivilege escalation, host crash (Denial of Service), and leaked\n\t    information all cannot be excluded.\u003c/p\u003e\n\t\u003c/blockquote\u003e\n      ",
  "affects": [
    {
      "name": "xen-kernel",
      "range": [
        {
          "lt": "4.5.2_1"
        }
      ]
    }
  ],
  "dates": {
    "discovery": "2015-12-17T00:00:00Z",
    "entry": "2016-01-06T00:00:00Z"
  },
  "references": [
    {
      "source": "URL",
      "text": "http://xenbits.xen.org/xsa/advisory-166.html"
    },
    {
      "source": "FreebsdPR",
      "text": "ports/205841"
    }
  ]
}
