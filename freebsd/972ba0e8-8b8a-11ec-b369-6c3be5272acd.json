{
  "vid": "972ba0e8-8b8a-11ec-b369-6c3be5272acd",
  "topic": "Node.js -- January 2022 Security Releases",
  "description": "\n\t\u003cp\u003eNode.js reports:\u003c/p\u003e\n\t\u003cblockquote cite=\"https://nodejs.org/en/blog/vulnerability/jan-2022-security-releases/\"\u003e\n\t  \u003ch1\u003eImproper handling of URI Subject Alternative Names (Medium)(CVE-2021-44531)\u003c/h1\u003e\n\t  \u003cp\u003eAccepting arbitrary Subject Alternative Name (SAN) types, unless a PKI is specifically defined to use a particular SAN type, can result in bypassing name-constrained intermediates. Node.js was accepting URI SAN types, which PKIs are often not defined to use. Additionally, when a protocol allows URI SANs, Node.js did not match the URI correctly.\u003c/p\u003e\n\t  \u003ch1\u003eCertificate Verification Bypass via String Injection (Medium)(CVE-2021-44532)\u003c/h1\u003e\n\t  \u003cp\u003eNode.js converts SANs (Subject Alternative Names) to a string format. It uses this string to check peer certificates against hostnames when validating connections. The string format was subject to an injection vulnerability when name constraints were used within a certificate chain, allowing the bypass of these name constraints.\u003c/p\u003e\n\t  \u003ch1\u003eIncorrect handling of certificate subject and issuer fields (Medium)(CVE-2021-44533)\u003c/h1\u003e\n\t  \u003cp\u003eNode.js did not handle multi-value Relative Distinguished Names correctly. Attackers could craft certificate subjects containing a single-value Relative Distinguished Name that would be interpreted as a multi-value Relative Distinguished Name, for example, in order to inject a Common Name that would allow bypassing the certificate subject verification.\u003c/p\u003e\n\t  \u003ch1\u003ePrototype pollution via \u003ccode\u003econsole.table\u003c/code\u003e properties (Low)(CVE-2022-21824)\u003c/h1\u003e\n\t  \u003cp\u003eDue to the formatting logic of the \u003ccode\u003econsole.table()\u003c/code\u003e function it was not safe to allow user controlled input to be passed to the \u003ccode\u003eproperties\u003c/code\u003e parameter while simultaneously passing a plain object with at least one property as the first parameter, which could be \u003ccode\u003e__proto__\u003c/code\u003e. The prototype pollution has very limited control, in that it only allows an empty string to be assigned to numerical keys of the object prototype.\u003c/p\u003e\n\t\u003c/blockquote\u003e\n      ",
  "affects": [
    {
      "name": "node",
      "range": [
        {
          "lt": "12.22.9",
          "ge": "12.0.0"
        },
        {
          "lt": "14.18.3",
          "ge": "14.0.0"
        },
        {
          "lt": "16.13.2",
          "ge": "16.0.0"
        },
        {
          "lt": "17.3.1",
          "ge": "17.0.0"
        }
      ]
    },
    {
      "name": "node16",
      "range": [
        {
          "lt": "16.13.2"
        }
      ]
    },
    {
      "name": "node14",
      "range": [
        {
          "lt": "14.18.3"
        }
      ]
    }
  ],
  "dates": {
    "discovery": "2022-01-10T00:00:00Z",
    "entry": "2022-02-12T00:00:00Z"
  },
  "references": [
    {
      "source": "URL",
      "text": "https://nodejs.org/en/blog/vulnerability/jan-2022-security-releases/"
    },
    {
      "source": "CVE",
      "text": "CVE-2021-44531"
    },
    {
      "source": "CVE",
      "text": "CVE-2021-44532"
    },
    {
      "source": "CVE",
      "text": "CVE-2021-44533"
    },
    {
      "source": "CVE",
      "text": "CVE-2022-21824"
    }
  ]
}
