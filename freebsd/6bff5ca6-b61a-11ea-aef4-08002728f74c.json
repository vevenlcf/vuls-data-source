{
  "vid": "6bff5ca6-b61a-11ea-aef4-08002728f74c",
  "topic": "curl -- multiple vulnerabilities",
  "description": "\n\t\u003cp\u003ecurl security problems:\u003c/p\u003e\n\t\u003cblockquote cite=\"https://curl.haxx.se/docs/security.html\"\u003e\n\t  \u003cp\u003eCVE-2020-8169: Partial password leak over DNS on HTTP redirect\u003c/p\u003e\n\t  \u003cp\u003elibcurl can be tricked to prepend a part of the password to the\n\t    host name before it resolves it, potentially leaking the partial\n\t    password over the network and to the DNS server(s).\u003c/p\u003e\n\t  \u003cp\u003elibcurl can be given a username and password for HTTP\n\t    authentication when requesting an HTTP resource - used for HTTP\n\t    Authentication such as Basic, Digest, NTLM and similar. The\n\t    credentials are set, either together with CURLOPT_USERPWD or\n\t    separately with CURLOPT_USERNAME and CURLOPT_PASSWORD. Important\n\t    detail: these strings are given to libcurl as plain C strings and\n\t    they are not supposed to be URL encoded.\u003c/p\u003e\n\t  \u003cp\u003eIn addition, libcurl also allows the credentials to be set in the\n\t    URL, using the standard RFC 3986 format:\n\t    http://user:password@host/path. In this case, the name and password\n\t    are URL encoded as that's how they appear in URLs.\u003c/p\u003e\n\t  \u003cp\u003eIf the options are set, they override the credentials set in the\n\t    URL.\u003c/p\u003e\n\t  \u003cp\u003eInternally, this is handled by storing the credentials in the \"URL\n\t    object\" so that there is only a single set of credentials stored\n\t    associated with this single URL.\u003c/p\u003e\n\t  \u003cp\u003eWhen libcurl handles a relative redirect (as opposed to an\n\t    absolute URL redirect) for an HTTP transfer, the server is only\n\t    sending a new path to the client and that path is applied on to the\n\t    existing URL. That \"applying\" of the relative path on top of an\n\t    absolute URL is done by libcurl first generating a full absolute\n\t    URL out of all the components it has, then it applies the redirect\n\t    and finally it deconstructs the URL again into its separate\n\t    components.\u003c/p\u003e\n\t  \u003cp\u003eThis security vulnerability originates in the fact that curl did\n\t    not correctly URL encode the credential data when set using one of\n\t    the curl_easy_setopt options described above. This made curl\n\t    generate a badly formatted full URL when it would do a redirect and\n\t    the final re-parsing of the URL would then go bad and wrongly\n\t    consider a part of the password field to belong to the host name.\u003c/p\u003e\n\t  \u003cp\u003eThe wrong host name would then be used in a name resolve lookup,\n\t    potentially leaking the host name + partial password in clear text\n\t    over the network (if plain DNS was used) and in particular to the\n\t    used DNS server(s).\u003c/p\u003e\n\t  \u003cp\u003eCVE-2020-8177: curl overwrite local file with -J\u003c/p\u003e\n\t  \u003cp\u003ecurl can be tricked by a malicious server to overwrite a local\n\t    file when using -J (--remote-header-name) and -i (--include) in the\n\t    same command line.\u003c/p\u003e\n\t  \u003cp\u003eThe command line tool offers the -J option that saves a remote\n\t    file using the file name present in the Content-Disposition:\n\t    response header. curl then refuses to overwrite an existing local\n\t    file using the same name, if one already exists in the current\n\t    directory.\u003c/p\u003e\n\t  \u003cp\u003eThe -J flag is designed to save a response body, and so it doesn't\n\t    work together with -i and there's logic that forbids it. However,\n\t    the check is flawed and doesn't properly check for when the options\n\t    are used in the reversed order: first using -J and then -i were\n\t    mistakenly accepted.\u003c/p\u003e\n\t  \u003cp\u003eThe result of this mistake was that incoming HTTP headers could\n\t    overwrite a local file if one existed, as the check to avoid the\n\t    local file was done first when body data was received, and due to\n\t    the mistake mentioned above, it could already have received and\n\t    saved headers by that time.\u003c/p\u003e\n\t  \u003cp\u003eThe saved file would only get response headers added to it, as it\n\t    would abort the saving when the first body byte arrives. A\n\t    malicious server could however still be made to send back virtually\n\t    anything as headers and curl would save them like this, until the\n\t    first CRLF-CRLF sequence appears.\u003c/p\u003e\n\t  \u003cp\u003e(Also note that -J needs to be used in combination with -O to have\n\t    any effect.)\u003c/p\u003e\n\t\u003c/blockquote\u003e\n      ",
  "affects": [
    {
      "name": "curl",
      "range": [
        {
          "lt": "7.71.0",
          "ge": "7.20.0"
        }
      ]
    }
  ],
  "dates": {
    "discovery": "2020-06-24T00:00:00Z",
    "entry": "2020-06-24T00:00:00Z"
  },
  "references": [
    {
      "source": "URL",
      "text": "https://curl.haxx.se/docs/security.html"
    },
    {
      "source": "URL",
      "text": "https://curl.haxx.se/docs/CVE-2020-8169.html"
    },
    {
      "source": "URL",
      "text": "https://curl.haxx.se/docs/CVE-2020-8177.html"
    },
    {
      "source": "CVE",
      "text": "CVE-2020-8169"
    },
    {
      "source": "CVE",
      "text": "CVE-2020-8177"
    }
  ]
}
